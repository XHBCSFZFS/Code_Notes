
<div align='center'><font size='70'>笔记</font></div>





<font color='red'>红色</font>

<span style='color:blue;background:black;font-size:20;font-family:Oxygen;'>文字</span>

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# 数据库

## SQL语言

> `Structured Query Language`一种特殊用途的编程语言，是一种数据库查询和程序设计语言，用于访问数据以及查询、和管理关系数据库系统

### 处理

#### 1. 字段大小写

```sql
UPPER(f_xxxx) -- 大写转换 
LOWER(F_XXXX) -- 小写转换
```

#### 2. 数据类型

`不同平台这两种用法存在差异,如果是编写跨数据库平台的可移植代码最好用CAST();如果是使用 SQL Server,并且需要关于日期格式转换的额外功能，那么CONVERT()可能更合适.`

- ### `CAST(expression AS data_type)`

```sql
-- 语法
SELECT CAST(123 AS VARCHAR(10));  -- 整数转换为字符类型
```

- ### `CONVERT(data_type, expression, [style])`

```sql
-- 语法
SELECT CONVERT(VARCHAR(10), 123); -- 整数转换为字符类型
-- 使用不同的 style 将日期转换为字符串
SELECT CONVERT(VARCHAR, GETDATE(), 112);  -- 输出为 YYYYMMDD
```

#### 3.  文本处理

- `TRIM()`

```sql
-- 删除字符串开始和结束的空格
SELECT TRIM('   OpenAI   ');  -- 结果: 'OpenAI'
```

- `SUBSTRING() or SUBSTR() 取决于具体数据库`

```sql
-- 从字符串中提取子字符串
SELECT SUBSTRING('OpenAI', 2, 4); -- 结果: 'penA'
```

- `CHAR_LENGTH() or 或 LEN`()

```sql
-- 返回字符串的长度
SELECT CHAR_LENGTH('OpenAI');  -- 结果: 6
```

- `CONCAT()`

```sql
-- 连接两个或多个字符串
SELECT CONCAT('Open', 'AI');  -- 结果: 'OpenAI'
```

- `POSITION()`

```sql
-- 在字符串中查找子字符串的位置
SELECT POSITION('pen' IN 'OpenAI');  -- 结果: 2
```

- `REPLACE()`

```sql
-- 替换字符串中的子字符串
SELECT REPLACE('OpenAI', 'AI', 'Source');  -- 结果: 'OpenSource'
```

#### 4.  数值处理

- `ROUND()`

```sql
-- 四舍五入数值
SELECT ROUND(123.4567, 2);  -- 结果: 123.46
```

- `FLOOR()`

```sql
-- 返回小于或等于给定数字的最大整数
SELECT FLOOR(123.4567);  -- 结果: 123
```

- `CEIL() or CEILING()`

```sql
-- 返回大于或等于给定数字的最小整数
SELECT CEILING(123.4567);  -- 结果: 124
```

#### 5. 日期和时间处理

- `CURRENT_DATE()、CURRENT_TIME()、NOW`

```sql
-- 返回当前日期、时间或日期和时间。
SELECT CURRENT_DATE;  -- 结果: 2023-09-06 (假设今天是2023-09-06)
```

- `DATE_PART() or EXTRACT()`

```sql
-- 从日期或时间值中提取部分信息，如年、月、日等
SELECT DATE_PART('YEAR', '2023-09-06');  -- 结果: 2023
```

- `DATE_ADD() or DATE_SUB()`

```sql
-- 为日期添加或减少特定的间隔
SELECT DATE_ADD('2023-09-06', INTERVAL 1 DAY);  -- 结果: 2023-09-07
```

- `例如 MySQL 中使用DATE_FORMAT()  例如 Oracle 和 PostgreSQL 中 使用TO_CHAR() 根据不同数据库进行选择`

```sql
-- 将日期格式化为 YYYY-MM-DD  在SQL Server中
SELECT FORMAT(GETDATE(), 'yyyy-MM-dd') AS FormattedDate;
-- 将日期格式化为 YYYY-MM-DD  在 Oracle, PostgreSQL 中
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') AS FormattedDate FROM DUAL; -- Oracle
SELECT TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD') AS 今天日期;  -- PostgreSQL 今天日期 : 2023-09-06

SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:SS')AS 今天日期; -- pgsql
```

#### 6. 聚合函数

- **SUM**  计算数值列的总和。

```sql
SELECT SUM(column_name) FROM table_name;
```

- **AVG**   计算数值列的灵。

```sql
SELECT AVG(column_name) FROM table_name;
```

- **COUNT**   计算行数。

```sql
SELECT COUNT(column_name) FROM table_name;
```

- **MAX** or **MIN** 返回列中的顶部和简单。

```sql
SELECT MAX(column_name), MIN(column_name) FROM table_name;
```















## 1.递归查询

```sql
--递归查询
-- 定义一个叫做Recursive_CTE的公共表表达式（CTE）
WITH Recursive_CTE AS
(
  -- 基础查询部分
  -- 这部分查询首先选取F_RKNO与我们所给的字符串strRKNO相匹配的记录
  SELECT F_RKNO, F_RKNO_OLD
  FROM dbo.T_CPRKHistory
  WHERE F_RKNO = '{strRKNO}'
  UNION ALL  -- UNION ALL 用于将基础查询的结果和递归查询的结果结合起来
  -- 递归查询部分
  -- 这部分查询选取F_RKNO等于上一次查询结果中的F_RKNO_OLD的记录
  SELECT T.F_RKNO, T.F_RKNO_OLD
  FROM dbo.T_CPRKHistory T
  INNER JOIN Recursive_CTE RC ON T.F_RKNO = RC.F_RKNO_OLD
)
-- 在Recursive_CTE查询的结果中选取符合条件（F_RKNO等于F_RKNO_OLD）的最初的记录
SELECT TOP 1 F_RKNO_OLD 
FROM Recursive_CTE 
WHERE F_RKNO = F_RKNO_OLD;
```

## 2. 根据查询到的数据更改某一字段 重新插入到表内

```sql
INSERT INTO dbo.T_FormStyle_Backup
SELECT '产品发料履历', <其他字段>
FROM dbo.T_FormStyle_Backup
WHERE F_FORMNAME = '压型发料履历'	
```





## 1. `PostgreSQL`

> `PostgreSQL `是一个强大、可靠和灵活的关系型数据库系统，适用于从小型应用到大型企业级应用的各种场景。

`PostgreSQL` 是一种高级的、功能齐全的、开源的关系型数据库管理系统 `RDBMS` 。它起源于加利福尼亚大学伯克利分校，并已经有超过 30 年的开发历史。以下是 `PostgreSQL` 的一些主要特点和优势：

> 1. **开源与社区支持**：PostgreSQL 是一个开源项目，由一个活跃的全球开发社区支持，并且有许多公司提供专业的支持服务。
> 2. **高级功能**：除了基本的 CRUD 操作和 SQL 查询外，PostgreSQL 还支持复杂的数据类型（如 JSON、hstore 和数组）和高级查询功能。
> 3. **可扩展性**：PostgreSQL 允许用户通过添加自定义函数、数据类型和其他扩展来定制其功能。
> 4. **并发与性能**：PostgreSQL 支持多版本并发控制（MVCC），这意味着它可以在多个事务之间有效地处理数据的并发读写操作。
> 5. **安全**：PostgreSQL 提供了多种加密和验证机制，如 SSL 支持、列级权限和基于角色的访问控制。
> 6. **跨平台**：PostgreSQL 可以在多种操作系统上运行，包括 Linux、Windows 和 macOS。
> 7. **数据完整性**：PostgreSQL 支持外键、非空约束、唯一约束和其他数据完整性功能，确保数据的准确性和一致性。
> 8. **备份与恢复**：PostgreSQL 提供了多种数据备份和恢复工具，确保数据的持久性和可用性。
> 9. **SQL 与过程语言**：除了 SQL 外，PostgreSQL 还支持存储过程，并提供了多种过程语言，如 PL/pgSQL、PL/Python、PL/Perl 等。
> 10. **扩展与插件**：有许多第三方插件和工具可以与 PostgreSQL 配合使用，以增强其功能和性能。
> 11. **地理信息系统**：PostgreSQL 与 PostGIS 扩展结合，为地理信息系统（GIS）提供了强大的支持。
> 12. **复制与高可用性**：PostgreSQL 支持多种复制方法，如基于日志的复制和基于触发器的复制，确保数据的高可用性和负载均衡。

Win端 安装参考 [Windows 10平台安装 PostgreSQL 14.2详细教程  alt + 点击进入 ](https://zhuanlan.zhihu.com/p/484450913)

Linux端 安装参考[Linux 上安装  PostgreSQL  alt +点击进入](https://www.runoob.com/postgresql/linux-install-postgresql.html)

### 1. 与 `SqlServer` 区别

1. **数据类型**:

- PostgreSQL 支持 JSON 和 JSONB 数据类型，而 SQL Server 支持 XML 和 JSON 数据类型。
- PostgreSQL 使用 `BYTEA` 类型存储二进制数据，而 SQL Server 使用 `VARBINARY` 或 `IMAGE`。
- PostgreSQL 中的自增字段使用 `SERIAL`，而 SQL Server 使用 `IDENTITY`。

2. **分页**:

- PostgreSQL: `LIMIT 10 OFFSET 20`PostgreSQL： `LIMIT 10 OFFSET 20` 
- SQL Server: `SELECT TOP 10 * FROM table OFFSET 20 ROWS`SQL Server： `SELECT TOP 10 * FROM table OFFSET 20 ROWS` 

3. **字符串连接**:

- PostgreSQL: 使用 `||`PostgreSQL： 使用 `||` 
- SQL Server: 使用 `+`SQL Server： 使用 `+` 

4. **系统函数**:

- 当前日期和时间：PostgreSQL 使用 `NOW()`，而 SQL Server 使用 `GETDATE()`。
- 字符串长度：PostgreSQL 使用 `LENGTH(string)`，而 SQL Server 使用 `LEN(string)`。

5. **变量声明**:

- PostgreSQL: 使用 `DECLARE variable_name TYPE;`，然后使用 `:=` 赋值。
- SQL Server: 使用 `DECLARE @variable_name TYPE`，然后使用 `SET` 赋值。

6. **存储过程**:

- 在 SQL Server 中，常用的是存储过程，使用 `CREATE PROCEDURE` 创建。
- 在 PostgreSQL 11 之前，没有真正的存储过程，但它支持函数，使用 `CREATE FUNCTION` 创建。

7. **临时表**:

- PostgreSQL: 使用 `CREATE TEMP TABLE` 创建临时表。
- SQL Server: 使用 `CREATE TABLE #TableName` 创建临时表。

8. **系统目录**:

- PostgreSQL 使用 `pg_catalog`，而 SQL Server 使用 `sys`。PostgreSQL 使用 ，而 SQL Server 使用 `pg_catalog` `sys` 。

9. **索引**:

- PostgreSQL 支持多种索引类型，如 B-tree、Hash、GiST、SP-GiST、GIN 和 BRIN。
- SQL Server 主要使用 B-tree 结构，但也支持 XML、空间和全文搜索索引。

10. **事务隔离级别**:

- PostgreSQL 支持 Read Committed、Repeatable Read、Serializable 和 Read Uncommitted。
- SQL Server 支持 Read Uncommitted、Read Committed、Repeatable Read、Serializable 和 Snapshot。SQL Server 支持 Read Uncomitted、Read commmitted、Repeatable Read、Serializable 和 snapshot。

**其他特性**:

- PostgreSQL 支持表继承。
- SQL Server 提供了集成的报告服务、分析服务和集成服务。

### 2.     基础用法

**模式（Schemas）**:

- PostgreSQL 使用模式来组织数据库对象，允许多个模式在同一个数据库中。
- SQL Server 的数据库对象是由模式拥有的，但模式主要用作命名空间和权限边界。

**锁**:

- PostgreSQL 使用 MVCC（多版本并发控制）来处理数据并发。
- SQL Server 使用锁和行版本控制。

**ILIKE vs. LIKE**：

- PostgreSQL 的 `ILIKE` 提供了不区分大小写的匹配。
- SQL Server 的 `LIKE` 是默认不区分大小写的，但这取决于服务器的排序规则。

```sql
CREATE SCHEMA dbo; ---创建模式
DROP SCHEMA public CASCADE; ---删除public模式
ALTER SCHEMA pubilc RENAME TO dbo; ---模式重命名
SHOW search_path;   ---默认搜索路径
SET search_path TO dbo;    ---设置默认模式dbo
ALTER USER postgres SET search_path TO dbo; ---更改postgres用户默认模式为dbo
```

#### 1. 检查pgsql数据库编码格式

```sql
SELECT datname, pg_encoding_to_char(encoding) FROM pg_database WHERE datname = 'dbname';
```











## 2.  `SQL Server`

### 1. 查找

#### SQL Server 上查找携带某一字段的表名

```sql
SELECT t.name AS table_name
FROM sys.columns c
JOIN sys.tables t ON c.object_id = t.object_id
WHERE c.name = '字段'
ORDER BY t.name;
```

#### SQL Server 上的内存资源占用

##### 1. 查找内存占用最高的前10个查询

```sql
//查找内存占用最高的前10个查询
SELECT TOP 10
    t.TEXT AS [SQL Text],
    s.execution_count AS [Execution Count],
    s.total_logical_reads AS [Total Logical Reads],
    s.total_logical_reads / s.execution_count AS [Avg Logical Reads],
    s.total_physical_reads AS [Total Physical Reads],
    s.total_physical_reads / s.execution_count AS [Avg Physical Reads],
    s.creation_time AS [Creation Time],
    s.query_hash,
    s.query_plan_hash
FROM sys.dm_exec_query_stats AS s
CROSS APPLY sys.dm_exec_sql_text(s.sql_handle) AS t
ORDER BY s.total_logical_reads DESC;

```

##### 2. 查找内存占用最高的前10个数据库

```sql
//查找内存占用最高的前10个数据库
SELECT TOP 10
    DB_NAME(database_id) AS [Database Name],
    COUNT(*) * 8 / 1024.0 AS [Cached Size (MB)]
FROM sys.dm_os_buffer_descriptors
GROUP BY database_id
ORDER BY [Cached Size (MB)] DESC;
```

##### 3. 内存中占用最高的前10个对象

```sql
//内存中占用最高的前10个对象 显示对象名称、对象ID、对象类型、索引名称、索引ID、分区号、分配单元类型以及缓存大小（MB）
SELECT TOP 10
    o.name AS [Object Name],
    o.object_id AS [Object ID],
    o.type_desc AS [Object Type],
    i.name AS [Index Name],
    i.index_id AS [Index ID],
    p.partition_number AS [Partition Number],
    au.type_desc AS [Allocation Unit Type],
    COUNT(*) * 8 / 1024.0 AS [Cached Size (MB)]
FROM sys.dm_os_buffer_descriptors AS b
JOIN sys.allocation_units AS au ON b.allocation_unit_id = au.allocation_unit_id
JOIN sys.partitions AS p ON (au.type IN (1, 3) AND au.container_id = p.hobt_id) OR (au.type = 2 AND au.container_id = p.partition_id)
JOIN sys.objects AS o ON p.object_id = o.object_id
JOIN sys.indexes AS i ON p.object_id = i.object_id AND p.index_id = i.index_id
WHERE b.database_id = DB_ID()
GROUP BY o.name, o.object_id, o.type_desc, i.name, i.index_id, p.partition_number, au.type_desc
ORDER BY [Cached Size (MB)] DESC;
```



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# *Linux*

<div align='center'><font size='70' color='#0a040f'>Linux</font></div>

> Linux 是一个开源的 Unix-like 操作系统内核，由 Linus Torvalds 于 1991 年首次发布。自那时起，Linux 已被多个团队和组织用于创建完整的操作系统发行版。这些发行版（或称为 "distros"）具有共同的 Linux 内核，但它们的软件、库、用户界面和管理工具各不相同。

## 流行的 Linux 发行版本

### **1. Debian** 

> - 稳定且重视安全。
> - 使用 `.deb` 包格式和 `apt` 包管理工具。
> - 适合服务器和桌面使用。
> - 大量的软件包。

### **2. Ubuntu**

> - 基于 Debian。
> - 用户友好，尤其适合 Linux 初学者。
> - 使用 `.deb` 包格式和 `apt` 包管理工具。
> - 有多个官方衍生版本，如 Ubuntu Server、Ubuntu Desktop、Kubuntu、Xubuntu 等。

### **3. Red Hat Enterprise Linux (RHEL)**

> - 适合企业环境，重视稳定性和安全性。
> - 使用 `.rpm` 包格式和 `yum` 包管理工具。
> - 商业支持和认证。
> - CentOS 是一个 RHEL 的免费克隆，但在 2020 年后转向 CentOS Stream。

### **4. Fedora**

> - RHEL 的上游项目。
> - 提供最新的软件和特性。
> - 使用 `.rpm` 包格式和 `dnf` 包管理工具。

**5. Arch Linux**

> - 简洁、轻量级、滚动发布。
> - 使用 `pacman` 作为包管理工具。
> - 适合中高级用户，需要手动配置很多东西。

### **6. Manjaro**

> - 基于 Arch Linux，但更加用户友好。
> - 提供多种桌面环境选择。
> - 使用 `pacman` 作为包管理工具。

**7. openSUSE**

> - 有两个主要版本：Tumbleweed（滚动发布）和 Leap（定期发布）。
> - 使用 `.rpm` 包格式。
> - YaST 是其独特的系统配置工具。

**8. Gentoo**

> - 源码为基础的发行版。
> - 用户可以为每个软件包设置特定的编译选项。
> - 使用 `emerge` 作为包管理工具。

**9. Slackware**

> - 最古老的发行版本之一。
> - 保持简单的原则。
> - 适合那些喜欢手动管理和配置的用户。

**10. Mint**

> - 基于 Ubuntu。
> - 用户友好，适合初学者。
> - 提供多种桌面环境选择，如 Cinnamon、MATE 和 Xfce。

`每个发行版本都有其独特的特点和用途。选择哪个版本取决于用户的需求、经验和喜好。以上所述发行版不是全部发行版本,仅供参考了解学习~`

## 基础命令

### **1. 文件操作**

- `ls`：列出目录内容

```shell
ls -l
```

- `cd`：改变当前目录  `进入名为 `documents` 的目录：`

```shell
cd documents
```

- `pwd`：显示当前目录

```shell
pwd
```

- `touch`：创建空文件 `创建一个名为 `test.txt` 的文件：`

```shell
touch test.txt
```

- `rm`：删除文件或目录 `删除上面创建的 `test.txt` 文件：`

```shell
rm test.txt
```

- `cp`：复制文件或目录 `复制 file1.txt 到 file2.txt`

```shell
cp file1.txt file2.txt
```

- `mv`：移动或重命名文件或目录  将 `file1.txt` 重命名为 `file3.txt`。

```shell
mv file1.txt file3.txt
```

### **2. 文本处理**

- `cat`：显示文件内容 `显示一个名为 `file.txt` 的文件的内容：`

```shell
cat file.txt
```

- `more` / `less`：分页显示文件内容  more向前浏览，但不允许向后。 less分页显示文本文件的内容。它比 `more` 功能更强大，允许您向前和向后浏览

```shell
more file.txt
less file.txt
```

- `grep`：文本搜索 `从 `file.txt` 中搜索包含 "linux" 的行：`

```shell
grep "linux" file.txt
```

- `sed`：流式文本编辑   在 `file.txt` 中将所有的 "apple" 替换为 "orange"。

```shell
sed 's/apple/orange/g' file.txt
```

- `awk`：文本和数据处理工具 `文本和数据提取和报告工具。它使用一个脚本来处理文件中的数据。`

```shell
awk '{print $2}' data.txt
```

- `cut`：切分文本 `从文件的每行中删除或提取部分。` 从 `data.txt` 中提取第二列的内容（使用冒号作为分隔符）。

```shell
cut -d':' -f2 data.txt
```

### **3. 权限和所有权**

- `chmod`：更改文件权限 `给 `script.sh` 添加执行权限：`

```shell
chmod +x script.sh
```

- `chown`：更改文件所有者 `将 `file.txt` 的所有者更改为 `john`：`

```shell
chown john file.txt
```

- `chgrp`：更改文件所属组 将 `file.txt` 的组更改为 `users`。

```shell
chgrp users file.txt
```

### **4. 网络**

- `ping`：测试网络连接  `ping -t`  连续测试网络连接 

```shell
ping google.com
ping google.com -t
```

- `ifconfig` / `ip`：显示或配置网络接口  `ifconfig/ip`查看所有网络接口的状态

```shell
ifconfig
ip addr
```

- `netstat`：显示网络状态 

```shell
netstat -a
```

- `ssh`：远程登录

```shell
ssh root@192.168.1.10
```

- `scp`：安全复制文件 将 `file.txt` 复制到上述 IP 地址的远程主机上。

```shell
scp file.txt user@192.168.1.10:/path/to/destination
```

- `nslookup` 域名解析 

```shell
nslookup xhbcfszfs.me
```

### **5. 磁盘和系统**

- `df`：显示磁盘使用情况

```shell
df -h
```

- `du`：显示目录或文件大小 `显示 `documents` 目录的大小`

```shell
du -sh documents
```

- `free`：显示内存使用情况

```shell
free -h
```

- `top` / `htop`：显示系统运行状态

```shell
top 
htop
```

### **6. 进程管理**

- `ps`：显示当前进程

```shell
ps aux
```

- `kill`：结束进程 `结束 PID 为 1234 的进程。`

```shell
kill 1234
```

- `pkill`：按名称结束进程  结束所有名为 `firefox` 的进程。

```shell
pkill firefox
```

- `bg`：将进程放到后台运行 如果您在一个进程中（例如 `nano` 编辑器）并按 `Ctrl+Z` 暂停了它，可以使用以下命令将其放到后台：

```shell
bg #放到后台
```

- `fg`：将后台进程放到前台运行

```shell
fg #放到前台
```

### **7. 压缩和备份**

- `tar`：打包和解包文件 将 `directory/` 打包为 `archive.tar.gz`。

```shell
tar czvf archive.tar.gz directory/
```

- `gzip` / `gunzip`：压缩和解压文件

```shell
gzip file.txt #压缩 file.txt。
gunzip file.txt.gz #解压 file.txt.gz。
```

- `zip` / `unzip`：压缩和解压文件

```shell
zip file.zip file.txt #将 file.txt 压缩为 file.zip。
unzip file.zip #解压 file.zip。
```

### **8. 软件和包管理**

- `apt-get`：Debian 和 Ubuntu 的软件包管理   `安装 nano` :

```shell
sudo apt-get install nano
```

- `yum`：RedHat 和 CentOS 的软件包管理 使用 `yum` 安装 `htop`。

```shell
yum install htop
```

- `dnf`：Fedora 的软件包管理 也是新版本的 CentOS 和 RHEL 中的默认包管理器，用于替代 `yum`。

```shell
dnf install htop
```

- `pacman`：Arch Linux 的软件包管理 使用 `pacman` 安装 `htop`。

```shell
pacman -S htop
```

### **9. 系统信息**

- `uname`：显示系统信息 查看完整的系统信息

```shell
uname -a
```

- `hostname`：显示或设置主机名

```shell
hostname
```

- `dmesg`：显示内核消息

```shell
dmesg
```

### **10 .其他**

- `echo`：输出文本或变量

```shell
echo "Hello, World!"
```

- `date`：显示或设置系统日期和时间

```shell
date
```

- `cal`：显示日历 显示当前月份的日历。

```shell
cal
```

- `alias`：创建命令别名 为 `ls -l` 命令创建一个别名 `ll`。

```shell
alias ll="ls -l"
```

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# **Git**

> Git是目前世界上最先进的分布式版本控制系统
>

## `SVN`与`Git`的最主要的区别？

SVN（Subversion）和Git都是版本控制系统，用于跟踪和管理软件项目中的代码变化。它们在一些关键方面有很大的区别：

1. **分布式 vs. 集中式**：
   - Git是分布式版本控制系统，每个开发者都拥有完整的代码仓库副本，可以在本地进行提交、分支创建等操作，然后通过网络同步变更。
   - SVN是集中式版本控制系统，项目有一个中央仓库，开发者需要从中央仓库获取代码，进行修改后再提交回中央仓库。
2. **仓库结构**：
   - Git中的仓库是整个项目的镜像，包含完整的历史记录和分支信息。每个本地仓库都是独立的，可以离线操作。
   - SVN中的仓库是一个中央仓库，开发者只能从中央仓库获取代码，并在提交时需要连接到中央仓库。
3. **速度**：
   - Git通常在本地操作时速度较快，因为大部分操作都在本地仓库进行。
   - SVN的一些操作需要访问网络，可能相对较慢。
4. **分支和合并**：
   - 在Git中，创建分支和合并分支相对较为轻松，开发者可以频繁创建分支来实现不同功能的开发，然后再将分支合并回主线。
   - 在SVN中，分支和合并相对复杂，需要在中央仓库中进行，有时需要手动解决冲突。
5. **历史记录**：
   - Git的历史记录是完整的、分布式的，每个本地仓库都包含完整的历史信息。
   - SVN的历史记录集中在中央仓库中，每个开发者只能看到自己的提交记录和中央仓库的历史。
6. **可用性**：
   - Git可以在没有网络连接的情况下进行工作，因为每个本地仓库都包含完整的代码和历史。
   - SVN需要连接到中央仓库才能获取代码或提交变更。

综上所述，Git更适合分布式团队、需要频繁分支合并和离线工作的场景，而SVN可能更适合相对简单的项目或者集中式团队。选择哪种版本控制系统取决于项目的需求和团队的工作流程。
<details>
    <summary>通俗来讲区别</summary>
<pre>
<text>
SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。
Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
</text>
</pre>
</details>
工作原理及其流程:

![img](https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_720w.webp)

## 基本常用动作

### 1. 提交代码动作

```xml
//git status  查看当前状态
//git add .  或者 git add xxx 一个提交全部 一个提交指定
//git commit -m "提交代码" 推送修改到本地git库中
//git pull <远程主机名> <远程分支名> 取回远程主机某个分支的更新，再与本地的指定分支合并。
//git push <远程主机名> <远程分支名>  把当前提交到git本地仓库的代码推送到远程主机的某个远程分之上
```

### 2. 设置分支链接

```yaml
// git remote get-url origin  查看当前分支的链接

// git remote set-url origin newUrl 设置当前分支的链接
```

### 3. 远程仓库覆盖本地

```yaml
# 拉取所有更新，不同步；
git fetch --all

# 本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；
git reset --hard origin/master

# 再更新一次（其实也可以不用，第二步命令做过了其实）
git pull
```

*以上三条语句可合并成一条语句执行*

```yaml
git fetch --all && git reset --hard origin/master && git pull
```

### 4. 更改Git连接

1. 使用以下命令查看当前的远程仓库连接：

```xm
git remote -v
```

2. 使用以下命令移除当前的远程仓库连接：

```xm
git remote remove origin
```

3. 使用以下命令添加新的远程仓库连接：

```xml
git remote add origin <新的Git连接>
```

4. 使用以下命令验证新的远程仓库连接是否成功添加：

```xml
git remote -v
```

### 5. 设置SSH Key连接

```xml
git remote set-url origin <ssh连接>
```

### 6. 快速交作业下班

配置终端  执行以下命令来创建一个 `git` 别名，我们这里称它为 `allpush`：

```shell
git config --global alias.allpush '!git add . && git commit -m "$1" && git pull && git push'
```

使用这个别名时，可以这样做：

```shell
git allpush "更改笔记"
```

注意：别名中的 `$1` 代表您提供的第一个参数，即提交信息。















---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------







# Vue 

`尤雨溪 独立开源软件开发者 twitter : @yuxiyou`

## **Vue.js 基础**

1. **核心概念**：Vue基于MVVM模式（Model-View-ViewModel），将用户界面分为视图、模型和ViewModel三部分，通过双向绑定实现数据的动态更新。
2. **指令**：Vue提供了一系列指令，如`v-bind`用于属性绑定，`v-model`用于双向绑定，`v-for`用于循环渲染等。
3. **模板语法**：Vue使用类似HTML的模板语法，通过插值和指令实现动态数据绑定。
4. **组件**：Vue允许将应用拆分为可重用的组件，每个组件包含自己的模板、逻辑和样式。
5. **生命周期钩子**：Vue组件具有一系列的生命周期钩子函数，允许在组件创建、更新和销毁等阶段执行自定义逻辑。

## **Vue 2 / 3 区别**

1. **性能优化**：Vue 3在虚拟DOM的实现上进行了优化，提升了渲染性能。它引入了基于Proxy的响应式系统，比Vue 2中的Object.defineProperty更高效。
2. **Composition API**：Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式，允许将相关逻辑组合成自定义的逻辑组合函数，提高了代码的可维护性。
3. **Teleport**：Vue 3引入了Teleport组件，允许将组件的内容渲染到DOM中的任何位置，而不受组件层次结构的限制。
4. **Fragment**：Vue 3中可以使用Fragment（<template>）包裹多个元素，而不必添加额外的父元素。
5. **全局API修改**：一些全局API在Vue 3中发生了变化，例如`v-bind`改为`v-model`的属性绑定功能，`v-on`改为`@`等。
6. **Tree-Shaking支持**：Vue 3更好地支持Tree-Shaking，使得只引入使用的代码，减小最终构建的大小。

## **ES6中的 const  var  let** 

### 1.作用域区别

```javascript
//var 声明的变量的作用域只能是全局或者整个函数块的。 使用var声明的变量会被提升到其作用域的顶部，在代码中可以在声明之前访问。
//let 声明的变量的作用域则是它当前所处代码块. let声明的变量不会被提升，只能在声明之后使用。
function Test() {
  var a = 1;
  let b = 1;
  {
  var a = 2; 
  let b = 2; 
  console.log(a); // 2
  console.log(b); // 2
  }
  console.log(a); // 2 var变量是全局的
  console.log(b); // 1 let变量只会影响当前区域
}
//let 声明的变量的作用域可以比 var 声明的变量的作用域有更小的限定范围，更具灵活。
```

### 2.**重复声明**

```javascript
//var 允许在同一作用域中重复声明，而 let 不允许在同一作用域中重复声明，否则将抛出异常。
function test() {
  var a = 3;
  var a = 4;
    
  let b = 1;
  let b = 2; 
    
  console.log(a) // 4
  console.log(b) // SyntaxError: Identifier 'b' has already been declared
}
//let 声明的重复性检查是发生在词法分析阶段，也就是在代码正式开始执行之前就会进行检查。
```

### 3.**绑定全局对象**

```javascript
//var 在全局环境声明变量，会在全局对象里新建一个属性，而 let 在全局环境声明变量，则不会在全局对象里新建一个属性。
var foo = 'global'
let bar = 'global'

console.log(this.foo) // global
console.log(this.bar) // undefined
//let 在全局环境声明变量 bar 保存在[[Scopes]][0]: Script这个变量对象的属性中，而[[Scopes]][1]: Global就是我们常说的全局对象。
```

### 4.**变量提升与暂存死区**

```javascript
console.log(a) // undefined
var a = 1;
console.log(a) // 1
```

```js
console.log(bar); // undefined 不存在
console.log(foo); // ReferenceError: foo is not defined 存在但是未定义
var bar = 1;
let foo = 2;
```

### **5. Const**

```js
//ES6引入的关键字(let const)
// const用于声明常量。与let类似，const也具有块级作用域，并且不会被提升。一旦用const声明一个变量，它的值就不能被修改，并且必须在声明时进行初始化。
function example() {
  if (true) {
    const x = 10;
    console.log(x); // 10
    x = 20; // Error: Assignment to constant variable
  }
```

### **6. 总结区别**

- 使用`var`声明的变量具有函数作用域，可以在整个函数内部访问。
- 使用`let`声明的变量具有块级作用域，只能在声明的块内部访问。
- 使用`const`声明的变量也具有块级作用域，且其值不能被修改。

推荐使用`let`和`const`来声明变量，而尽量避免使用`var`，以避免潜在的作用域问题和变量提升带来的困惑。

## Vue 2 生命周期钩子

### 1. 创建阶段

1. `beforeCreate`: 在实例被创建之前调用，此时组件的数据观测和事件机制尚未初始化。
2. `created`: 在实例创建完成后调用，此时已完成数据观测，可以访问数据、计算属性、方法和侦听器，但尚未挂载到DOM。

### 2. 挂载阶段

1. `beforeMount`: 在挂载开始之前调用，此时模板编译已完成，但尚未将模板渲染到DOM中。
2. `mounted`: 在挂载完成后调用，此时组件已经被挂载到DOM中，可以操作DOM节点。

### 3. 更新阶段

1. `beforeUpdate`: 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在此修改数据。
2. `updated`: 在数据更新之后调用，发生在虚拟DOM重新渲染和打补丁之后，可以操作更新后的DOM。

### 4. 销毁阶段

1. `beforeDestroy`: 在实例销毁之前调用，此时实例仍然完全可用。
2. `destroyed`: 在实例销毁之后调用，此时Vue实例的所有指令都已解绑，事件监听器已被移除，子实例也被销毁。

### 5. 激活与停用阶段

1. `activated `(仅`keep-alive`组件): 在组件被激活时调用。
2. `deactivated `(仅`keep-alive`组件): 在组件被停用时调用。

## Vue 3 生命周期钩子

Vue 3中的生命周期钩子函数有所变化，并引入了新的API。

### 1. 创建阶段

1. `beforeCreate`: 在实例被创建之前调用。
2. `created`: 在实例创建完成后调用，此时已完成数据观测，可以访问数据、计算属性、方法和侦听器，但尚未挂载到DOM。
3. `onBeforeMount`: 在挂载开始之前调用。
4. `onMounted`: 在挂载完成后调用，此时组件已经被挂载到DOM中，可以操作DOM节点。

### 2. 更新阶段

1. `onBeforeUpdate`: 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在此修改数据。
2. `onUpdated`: 在数据更新之后调用，发生在虚拟DOM重新渲染和打补丁之后，可以操作更新后的DOM。

### 3. 销毁阶段

1. `onBeforeUnmount`: 在实例销毁之前调用，此时实例仍然完全可用。
2. `onUnmounted`: 在实例销毁之后调用，此时Vue实例的所有指令都已解绑，事件监听器已被移除，子实例也被销毁。

### 4. 组件状态更新阶段

1. `onActivated `(仅`<keep-alive>`组件): 在组件被激活时调用。
2. `onDeactivated `(仅`<keep-alive>`组件): 在组件被停用时调用。

## 核心特性和API

### 1. ` computed`

`computed`属性用于定义`计算属性`，它会根据响应式数据的变化自动更新计算结果。在Vue组件中，你可以使用`computed`选项来定义计算属性。

`computed`方法在Vue 2和Vue 3中都存在，但在Vue 3中有一些语法上的变化：

在Vue 2中，计算属性和观察者的定义使用对象字面量的形式，例如：

```js
// Vue 2的计算属性
computed: {
  fullName: function() {
    return this.firstName + ' ' + this.lastName;
  }
},
```

而在Vue 3中，计算属性的定义使用函数的形式，例如：

```js
// Vue 3的计算属性
computed: {
  fullName() {
    return this.firstName + ' ' + this.lastName;
  }
},
```

### 2.  `watch`

`watch`属性用于 `观察响应式数据 `的变化，并在数据变化时执行相应的回调函数。你可以通过`watch`选项来定义一个或多个观察者。

`watch`方法在Vue 2和Vue 3中都存在，但在Vue 3中有一些语法上的变化：

```js
// Vue 2的观察者
watch: {
  firstName: function(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  },
  lastName: function(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  }
}
```

Vue 3中，观察者的定义使用函数的形式，例如：

```js
// Vue 3的观察者
watch: {
  firstName(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  },
  lastName(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  }
}
```

除了生命周期钩子函数以外，Vue 2和Vue 3还提供了其他一些常用的方法，用于操作组件、数据和DOM等。以下是一些常见的方法：

### 3.  `methods`

`methods`选项用于定义组件中的方法。这些方法可以在组件的模板中被调用，也可以在组件的其他方法中使用。

```js
//在Vue 2中：
export default {
  methods: {
    handleClick() {
      // 处理点击事件的逻辑
    }
  }
}
```

```js
//在Vue 3中：
import { ref } from 'vue';
export default {
  setup() {
    const handleClick = () => {
      // 处理点击事件的逻辑
    };
    return {
      handleClick
    };
  }
}
```

### 4. `data`

`data`选项用于定义组件的数据。你可以在`data`中声明组件的响应式数据，并在组件的模板和方法中使用。

在Vue 2中，可以使用`data`选项来定义组件的数据。例如：

```js
export default {
  data() {
    return {
      message: 'Hello, Vue!'
    };
  }
}
```

而在Vue 3中，使用`data`选项被弃用，推荐使用`setup`函数和响应式数据对象。例如：

```js
import { reactive } from 'vue';

export default {
  setup() {
    const data = reactive({
      message: 'Hello, Vue!'
    });

    return {
      data
    };
  }
}
```

### 5. `props`

`props`选项用于定义组件的属性。通过`props`，父组件可以向子组件传递数据，子组件可以接收和使用这些数据。

在Vue 2和Vue 3中，可以通过`props`选项来定义组件的属性。例如，在Vue 2和Vue 3中：

```js
export default {
  props: ['title']
}
```

### 6.  `$emit`

`$emit`是一个实例方法，用于触发当前组件实例上的自定义事件。通过`$emit`方法，你可以在子组件中向父组件发送自定义事件，并传递数据。

在组件实例中，可以使用`$emit`方法来触发自定义事件。例如，在Vue 2和Vue 3中：

```js
// 触发自定义事件
this.$emit('my-event', eventData);
```

### 7. `$refs`

`$refs`是一个实例属性，用于在组件中访问子组件或DOM元素。通过给组件或DOM元素添加`ref`属性，你可以通过`$refs`来引用它们。

在组件实例中，可以通过`$refs`属性来访问子组件或DOM元素。例如，在Vue 2和Vue 3中：

```js
// 访问子组件或DOM元素
this.$refs.myComponent  // 子组件的引用
this.$refs.myElement   // DOM元素的引用
```

### 8.  `$nextTick`

`$nextTick`是一个实例方法，用于在下次DOM更新循环结束之后执行回调函数。它可以在DOM更新后执行一些操作，例如访问更新后的DOM元素。

```js
// 在下次DOM更新循环结束后执行回调函数
this.$nextTick(() => {
  // 在DOM更新后执行的操作
});
```

### 9. `v-on` `@`

`v-on（或简写为 @ ）`是一个指令，用于监听DOM事件，并在事件触发时执行相应的方法。通过`v-on`，你可以绑定事件监听器到DOM元素上。

```js
<!-- 监听点击事件 -->
<button v-on:click="handleClick">Click Me</button>

<!-- 使用简写语法 -->
<button @click="handleClick">Click Me</button>

```

### 10.  `v-bind`  `:`

`v-bind（或简写为 : ）` 是一个指令，用于动态地绑定HTML属性或组件的属性。通过`v-bind`，你可以将数据绑定到组件或DOM元素的属性上。

```js
<!-- 动态绑定属性 -->
<div v-bind:class="{'red': isRed}"></div>

<!-- 使用简写语法 -->
<div :class="{'red': isRed}"></div>
```

### 11. `v-for`

`v-for`是一个指令，用于渲染列表数据。通过`v-for`，你可以根据数据循环渲染DOM元素或组件。

```js
<!-- 渲染列表 -->
<ul>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>
```

### 12. `v-if`

`v-if`是一个指令，用于条件性地渲染DOM元素或组件。通过`v-if`，你可以根据条件判断来决定是否渲染特定的元素或组件。

```js
<!-- 条件渲染 -->
<div v-if="isVisible">Visible</div>
```



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# DataV

```js
<dv-loading>Loading...</dv-loading>  -- 显示加载组件
```

















































# **VB.NET**

## 基本使用

### 1. 类型转换

```vb
Convert.ToDecimal(Row("F_xxxx")) '举例将字符转换成数字
```

### 2. 截取字符串

```vb
Row("F_BQXLH").ToString().Substring(0, 2) = "RK" '截取前两位判断
```

### 3. 获取C1ComboBox1的下拉取值

```vb
 ' 获取选中的线体信息作为下拉框值
Dim selectedStrval As String = C1ComboBox1.SelectedItem.ToString()
```

### 4. 删除选中

```vb
    Private Sub Button4_Click(sender As Object, e As EventArgs) Handles Button4.Click
        Dim selectedRows As DataRow() = CType(C1FlexGrid1.DataSource, DataTable).Select($"F_DEL={True}")
        If selectedRows.Length > 0 Then
            Dim result As DialogResult = MessageBox.Show($"确定要删除选中的 {selectedRows.Count} 条记录吗？", "确认删除", MessageBoxButtons.YesNo, MessageBoxIcon.Question)
            If result = DialogResult.Yes Then
                Dim dataTable As DataTable = CType(C1FlexGrid1.DataSource, DataTable)
                For Each row In selectedRows
                    dataTable.Rows.Remove(row)
                Next
            End If
        Else
            MessageBox.Show("请勾选要删除的记录！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
        End If
    End Sub
```

### 5. 全选反选

```vb
    '全选 反选
    Private Sub Button3_Click(sender As Object, e As EventArgs) Handles Button3.Click
        ' 检查C1FlexGrid1是否有数据
        If csDatatableC1 IsNot Nothing AndAlso csDatatableC1.Rows.Count > 0 Then
            ' 检查当前按钮文本，执行全选或取消操作
            If Button3.Text = "全选" Then
                For Each row As DataRow In csDatatableC1.Rows
                    row("F_DEL") = True
                Next
                Button3.Text = "反选"
            ElseIf Button3.Text = "反选" Then
                For Each row As DataRow In csDatatableC1.Rows
                    row("F_DEL") = False
                Next
                Button3.Text = "全选"
            End If
            ' 刷新C1FlexGrid1显示
            C1FlexGrid1.Refresh()
        Else
            MessageBox.Show("当前没有数据无法选中,请确认！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
        End If
    End Sub
```

### 6. 禁用以及隐藏

```vb
'禁用
Private Sub RadioButton1_CheckedChanged(sender As Object, e As EventArgs) Handles RadioButton1.CheckedChanged
    If RadioButton1.Checked Then
        ' RadioButton1被选中时的操作
        RadioButton6.Enabled = False ' 禁用RadioButton6
        RadioButton7.Enabled = False ' 禁用RadioButton7
        RadioButton8.Enabled = False ' 禁用RadioButton8
    Else
        ' RadioButton1未被选中时的操作
        RadioButton6.Enabled = True ' 恢复RadioButton6的可用性
        RadioButton7.Enabled = True ' 恢复RadioButton7的可用性
        RadioButton8.Enabled = True ' 恢复RadioButton8的可用性
    End If
End Sub
'如果你想要隐藏RadioButton6、RadioButton7和RadioButton8，可以将Enabled属性替换为Visible属性，并将其设置为False来隐藏它们。
Private Sub RadioButton1_CheckedChanged(sender As Object, e As EventArgs) Handles RadioButton1.CheckedChanged
    If RadioButton1.Checked Then
        ' RadioButton1被选中时的操作
        RadioButton6.Visible = False ' 隐藏RadioButton6
        RadioButton7.Visible = False ' 隐藏RadioButton7
        RadioButton8.Visible = False ' 隐藏RadioButton8
    Else
        ' RadioButton1未被选中时的操作
        RadioButton6.Visible = True ' 恢复RadioButton6的可见性
        RadioButton7.Visible = True ' 恢复RadioButton7的可见性
        RadioButton8.Visible = True ' 恢复RadioButton8的可见性
    End If
End Sub
```

### 7.  提示窗口弹出

#### 1.  可关闭提示框

```vb
MessageBox.Show("当前没有数据无法选中,请确认！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
```

#### 2. 不可关闭提示框

```vb
'某一窗体关闭的提示确认框!     
Private Sub Frm_Main_FormClosing(sender As Object, e As FormClosingEventArgs) Handles Me.FormClosing

        Dim bolEnable As Boolean = False
        If MessageBox.Show("xxx软件确定关闭吗？", Me.Text, MessageBoxButtons.YesNo, MessageBoxIcon.Question) = DialogResult.No Then
            e.Cancel = True'窗体仍然不会关闭
        Else
            Using csFrm_PassWord As New Frm_CloseEnter
                If csFrm_PassWord.ShowDialog = DialogResult.OK Then
                Else
                    e.Cancel = True'窗体仍然不会关闭
                End If
            End Using
        End If
    End Sub
```

#### 3. 输入提示框

```vb
Dim result As String = InputBox("请输入您要输入的：")
```

#### 4. 颜色选择提示框

```vb
Dim colorDialog As New ColorDialog()
colorDialog.ShowDialog()
Dim selectedColor As Color = colorDialog.Color
```







### 8.  位运算符 

1. `And` - 位与操作。如果两位都为 1，则结果为 1，否则结果为 0。

   例如：`5 And 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 And 3` 的结果是 1。

2. `Or` - 位或操作。如果两位中至少有一位为 1，则结果为 1，否则结果为 0。

   例如：`5 Or 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 Or 3` 的结果是 7。

3. `Xor` - 位异或操作。如果两位不相同，则结果为 1，否则结果为 0。

   例如：`5 Xor 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 Xor 3` 的结果是 6。

4. `Not` - 位非操作。对每一位进行取反。

   例如：`Not 5`，因为 5 是 101（二进制），取反后得到 010（二进制），结果是 2。

5. `<<` - 左移操作符。将位向左移动指定的位数。例如，`5 << 2`将数字5（101二进制）向左移动2位，结果是20（10100二进制）。

6. `>>` - 右移操作符。将位向右移动指定的位数。例如，`20 >> 2`将数字20（10100二进制）向右移动2位，结果是5（101二进制）。

这些运算符在处理二进制数据，尤其是在底层编程、网络编程和图形编程等方面非常有用。

### 9  逻辑运算符

逻辑运算符在 VB.NET 中用于执行逻辑运算，比如 `And`、`Or`、`Not`、`IsTrue`、`IsFalse`、`AndAlso` 和 `OrElse`。

1. `AndAlso`：也称为逻辑与操作符。它会先计算第一个操作数，如果第一个操作数为 False，那么就不会计算第二个操作数，因为无论第二个操作数的值是什么，结果都是 False。这种现象称为短路行为。

2. `OrElse`：也称为逻辑或操作符。如果第一个操作数为 True，则不会计算第二个操作数，因为无论第二个操作数的值是什么，结果都是 True。这也是一种短路行为。
3. `And`：逻辑与运算符。如果两个操作数都为 True，那么结果为 True，否则结果为 False。与 `AndAlso` 不同，它不具备短路行为，即它总是会评估两个操作数。
4. `Or`：逻辑或运算符。如果两个操作数中至少有一个为 True，那么结果为 True，否则结果为 False。与 `OrElse` 不同，它不具备短路行为，即它总是会评估两个操作数。
5. `Not`：逻辑非运算符。如果操作数为 True，那么结果为 False，如果操作数为 False，那么结果为 True。
6. `IsTrue` 和 `IsFalse`：这些运算符用于确定一个表达式是否返回 True 或 False。但是，一般来说，我们更常用的是 `=` 运算符来进行布尔比较，比如 `If a = True Then`。

































## 1.窗体关闭事件

一般来说都是this.close(); 方法调用一下就可以了。

这像是以前 VB 的写法，VB.net 里不是这样的，应该是：

```vb
Private Sub Form_Closed(ByVal sender As Object, ByVal e As System.EventArgs) Handles MyBase.Closed
MagBox("1111")
End Sub '注意，... Handles MyBase.Closed 是在同一行里的。
```

## 2.  窗体的所有事件

|                      名称                      |                             说明                             |
| :--------------------------------------------: | :----------------------------------------------------------: |
|                 Activated激活                  |             当使用代码激活或用户激活窗体时发生。             |
|       AutoSizeChanged自动调整大小已更改        |                 当 AutoSize 属性更改时发生。                 |
|       AutoValidateChanged自动验证已更改        |               当 AutoValidate 属性更改时发生。               |
|         BackColorChanged背面颜色已更改         |    当 BackColor 属性的值更改时发生。（从 Control 继承。）    |
|      BackgroundImageChanged背景图像已更改      | 当 BackgroundImage 属性的值更改时发生。（从 Control 继承。） |
| BackgroundImageLayoutChanged背景图像布局已更改 | 当 BackgroundImageLayout 属性更改时发生。（从 Control 继承。） |
|     BindingContextChanged绑定上下文已更改      | 当 BindingContext 属性的值更改时发生。（从 Control 继承。）  |
|     CausesValidationChanged原因验证已更改      | 当 CausesValidation 属性的值更改时发生。（从 Control 继承。） |
|            ChangeUICues更改用户界面            | 焦点或键盘用户界面 (UI) 提示更改时发生。（从 Control 继承。） |
|                   Click点击                    |           在单击控件时发生。（从 Control 继承。）            |
|       ClientSizeChanged客户端大小已更改        |   当 ClientSize 属性的值更改时发生。（从 Control 继承。）    |
|                    Closed闭                    |                       关闭窗体时发生。                       |
|                  Closing关闭                   |                       关闭窗体时发生。                       |
|       ContextMenuChanged上下文菜单已更改       |   当 ContextMenu 属性的值更改时发生。（从 Control 继承。）   |
|   ContextMenuStripChanged上下文菜单条已更改    | 当 ContextMenuStrip 属性的值更改时发生。（从 Control 继承。） |
|             ControlAdded控件已添加             | 在将新控件添加到 Control.ControlCollection 时发生。（从 Control 继承。） |
|            ControlRemoved控件已删除            | 在从 Control.ControlCollection 移除控件时发生。（从 Control 继承。） |
|            CursorChanged光标已更改             |     当 Cursor 属性的值更改时发生。（从 Control 继承。）      |
|                 Deactivate关闭                 |            当窗体失去焦点并不再是活动窗体时发生。            |
|                  Disposed处置                  | 当通过调用 Dispose 方法释放组件时发生。（从 Component 继承。） |
|             DockChanged坞站已更改              |      当 Dock 属性的值更改时发生。（从 Control 继承。）       |
|                DoubleClick双击                 |           在双击控件时发生。（从 Control 继承。）            |
|                  DragDrop拖放                  |          拖放操作完成时发生。（从 Control 继承。）           |
|               DragEnter拖动输入                |     在将对象拖入控件的边界时发生。（从 Control 继承。）      |
|               DragLeave拖拽离开                |      将对象拖出控件的边界时发生。（从 Control 继承。）       |
|                  DragOver拖拽                  |     在将对象拖到控件的边界上发生。（从 Control 继承。）      |
|           EnabledChanged已启用已更改           |      在 Enabled 属性值更改后发生。（从 Control 继承。）      |
|                   Enter进入                    |            进入控件时发生。（从 Control 继承。）             |
|             FontChanged字体已更改              |       在 Font 属性值更改时发生。（从 Control 继承。）        |
|           ForeColorChanged前色已更改           |     在 ForeColor 属性值更改时发生。（从 Control 继承。）     |
|              FormClosed表单已关闭              |                       关闭窗体后发生。                       |
|              FormClosing表单关闭               |                       关闭窗体前发生。                       |
|              GiveFeedback给予反馈              |        在执行拖动操作期间发生。（从 Control 继承。）         |
|                GotFocus得到焦点                |         在控件接收焦点时发生。（从 Control 继承。）          |
|             HandleCreated句柄创建              |        在为控件创建句柄时发生。（从 Control 继承。）         |
|           HandleDestroyed句柄已销毁            |   在控件的句柄处于销毁过程中时发生。（从 Control 继承。）    |
|        HelpButtonClicked帮助按钮已点击         |                    单击“帮助”按钮时发生。                    |
|           HelpRequested已请求的帮助            |        用户请求控件帮助时发生。（从 Control 继承。）         |
|          ImeModeChanged图像模式已更改          |       在 ImeMode 属性更改后发生。（从 Control 继承。）       |
|       InputLanguageChanged输入语言已更改       |                  更改窗体的输入语言后发生。                  |
|       InputLanguageChanging输入语言更改        |             当用户尝试更改窗体的输入语言时发生。             |
|                Invalidated失效                 |     控件的显示要求重新绘制时发生。（从 Control 继承。）      |
|                 KeyDown键向下                  |   在控件有焦点的情况下按下键时发生。（从 Control 继承。）    |
|                  KeyPress按键                  | 在控件有焦点的情况下字符、空格或退格键时发生。（从 Control 继承。） |
|                   KeyUp键控                    |   在控件有焦点的情况下释放键时发生。（从 Control 继承。）    |
|                   Layout布局                   |    在控件应重新定位其子控件时发生。（从 Control 继承。）     |
|                   Leave离开                    |       在输入焦点离开控件时发生。（从 Control 继承。）        |
|                    Load负荷                    |                   在第一次显示窗体前发生。                   |
|           LocationChanged位置已更改            |     在 Location 属性值更改后发生。（从 Control 继承。）      |
|                 LostFocus失焦                  |         在控件失去焦点时发生。（从 Control 继承。）          |
|            MarginChanged边距已更改             |                  当 Margin 属性更改时发生。                  |
|     MaximizedBoundsChanged最大化边界已更改     |           在 MaximizedBounds 属性的值更改后发生。            |
|        MaximumSizeChanged最大大小已更改        |             在 MaximumSize 属性的值更改后发生。              |
|        MdiChildActivateMdiChildActivate        |  在多文档界面 (MDI) 应用程序内激活或关闭 MDI 子窗体时发生。  |
|              MenuComplete菜单完成              |                  当窗体菜单失去焦点时发生。                  |
|               MenuStart菜单开始                |                  当窗体菜单接收焦点时发生。                  |
|        MinimumSizeChanged最小大小已更改        |             在 MinimumSize 属性的值更改后发生。              |
|       MouseCaptureChanged鼠标捕获已更改        |       当控件失去鼠标捕获时发生。（从 Control 继承。）        |
|               MouseClick鼠标点击               |         用鼠标单击控件时发生。（从 Control 继承。）          |
|            MouseDoubleClick鼠标双击            |         用鼠标双击控件时发生。（从 Control 继承。）          |
|               MouseDown鼠标向下                | 当鼠标指针位于控件上并按下鼠标键时发生。（从 Control 继承。） |
|               MouseEnter鼠标输入               |       在鼠标指针进入控件时发生。（从 Control 继承。）        |
|               MouseHover鼠标悬停               |     在鼠标指针停放在控件上时发生。（从 Control 继承。）      |
|               MouseLeave鼠标离开               |       在鼠标指针离开控件时发生。（从 Control 继承。）        |
|               MouseMove鼠标移动                |      在鼠标指针移到控件上时发生。（从 Control 继承。）       |
|                MouseUp鼠标向上                 | 在鼠标指针在控件上并释放鼠标键时发生。（从 Control 继承。）  |
|               MouseWheel鼠标滚轮               |    在控件有焦点且鼠标轮移动时发生。（从 Control 继承。）     |
|                    Move移动                    |           在移动控件时发生。（从 Control 继承。）            |
|            PaddingChanged填充已更改            |        在控件空白区更改时发生。（从 Control 继承。）         |
|                    Paint漆                     |           在重绘控件时发生。（从 Control 继承。）            |
|               ParentChanged父改                |      在 Parent 属性值更改时发生。（从 Control 继承。）       |
|            PreviewKeyDown预览键向下            | 在焦点位于此控件上的情况下，当有按键动作时发生（在 KeyDown 事件之前发生）。（从Control 继承。） |
|     QueryAccessibilityHelp查询辅助功能帮助     | 在 AccessibleObject 为辅助功能应用程序提供帮助时发生。（从 Control 继承。） |
|         QueryContinueDrag查询继续拖动          | 在拖放操作期间发生，并且允许拖动源确定是否应取消拖放操作。（从 Control 继承。） |
|            RegionChanged区域已更改             |     当 Region 属性的值更改时发生。（从 Control 继承。）      |
|                   Resize调整                   |         在调整控件大小时发生。（从 Control 继承。）          |
|            ResizeBegin调整大小开始             |                 窗体进入大小调整模式时发生。                 |
|             ResizeEnd调整大小结束              |                 窗体退出大小调整模式时发生。                 |
|         RightToLeftChanged从右到左更改         |    在 RightToLeft 属性值更改时发生。（从 Control 继承。）    |
|   RightToLeftLayoutChanged从右到左布局已更改   |           更改 RightToLeftLayout 属性值之后发生。            |
|                   Scroll滚动                   |                 用户或代码滚动工作区时发生。                 |
|             SizeChanged大小已更改              |       在 Size 属性值更改时发生。（从 Control 继承。）        |
|             StyleChanged风格已更改             |                    当窗体样式更改时发生。                    |
|       SystemColorsChanged系统颜色已更改        |                     显示设置更改时发生。                     |
|        TabIndexChanged选项卡索引已更改         |     当 TabIndex 属性值更改时发生。（从 Control 继承。）      |
|          TabStopChangedTabStopChanged          |      当 TabStop 属性值更改时发生。（从 Control 继承。）      |
|             TextChanged文本已更改              |       在 Text 属性值更改时发生。（从 Control 继承。）        |
|                 Validated验证                  |        在验证控件的内容时发生。（从 Control 继承。）         |
|                 Validating验证                 |           在验证控件时发生。（从 Control 继承。）            |
|            VisibleChanged可见已更改            |      在 Visible 属性值更改时发生。（从 Control 继承。）      |
|                 VScrollVScroll                 |        在垂直滚动条滚动时发生。（从 Control 继承。）         |

## 3. vb命令按钮退出怎么设置？

在退出按钮的Click事件中用Unload Me就可以关闭窗体。

```vb
Private Sub Command1_Click()
Unload Me
End Sub
```

答案补充 :

代码就是我回答那些了，双击按钮把代码输入进去就行了。对了，你的是VB6还是VB.Net啊？VB6就是用Unload Me，如果是VB.Net应该用Me.Close()。

```vb
'这个是VB.Net的代码：

Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button2.Click
Me.Close()
End Sub
```

## 窗体关闭事件

直接上代码:

```vb
Private Sub Form1_FormClosing(ByVal sender As System.Object, ByVal e As System.Windows.Forms.FormClosingEventArgs) 
MsgBox("窗口即将关闭....") 
End Sub
Else 
  e.Cancel = True 
End If
```

## 窗体的退出事件 vb.net

既然是VB.NET，那么，窗体关闭的事件，是.net framework提供的，是FormClosed事件。也是两个参数，一个object sender这个是object基类，整个.net framework都是从它派生的，一个 EventArgs  e，事件处理基类，一切事件是从EventArgs基类派生出来的。

## vb.net窗体关闭的问题

```VB
Private Sub frmNotepad_Closing(ByVal sender As Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing
    Call subexit()
End Sub

Sub subexit()
    Dim frmNew As frmNotepad
    frmNew = ActiveForm

    If frmNew.Text = "未定标题 - 记事本" Then
        If frmNew.rtb.Text = "" Then
        Else
            Dim result As New MsgBoxResult 'result提示对话框yes,no,cancel
            result = MsgBox("未定标题文件的文字已经改变。" & Chr(10) & Chr(10) & "想保存文件吗？", MsgBoxStyle.YesNoCancel + MsgBoxStyle.Exclamation, "记事本")

            If result = MsgBoxResult.Yes Then 'result.Yes表示保存，清空内容，打开新页面
                Dim fileSave As New SaveFileDialog
                Dim re As New DialogResult 're提示对话框OK，cancel

                fileSave.FileName = "*.txt"
                fileSave.Filter = "文本文档(*.txt)|*.txt|所有文件|*.*"
                re = fileSave.ShowDialog()

                If re = DialogResult.OK Then 're.OK表示成功保存，清空内容，打开新页面
                    filename = fileSave.FileName
                    Dim fstream As FileStream
                    Dim sw As StreamWriter

                    Try
                        'frmNew.Text = filename.Substring(filename.LastIndexOf("\") + 1) & "- 记事本"
                        fstream = New FileStream(filename, FileMode.Create, FileAccess.ReadWrite)
                        sw = New StreamWriter(fstream, System.Text.Encoding.Default)
                        sw.BaseStream.Seek(0, SeekOrigin.End)
                        sw.Write(rtb.Text)
                        sw.Flush()
                    Catch ex As Exception
                        MsgBox("保存文件失败")
                    Finally
                        sw.Close()
                    End Try
                ElseIf re = DialogResult.Cancel Then 're.cancel表示不保存，不改变任何结果
                End If
            ElseIf result = MsgBoxResult.No Then 'result.no表示不保存，清空内容
                rtb.Text = ""
            End If
        End If
    Else
        If rtb.Text.Compare(rtb.Text, compareStr) <> 0 Then
            Dim result As New MsgBoxResult
            result = MsgBox(filename & " 文件的文字已经改变。" & Chr(10) & Chr(10) & "想保存文件吗？", MsgBoxStyle.YesNoCancel + MsgBoxStyle.Exclamation, "记事本")

            If result = MsgBoxResult.Yes Then
                Dim fstream As FileStream
                Dim sw As StreamWriter

                Try
                    'frmNew.Text = filename.Substring(filename.LastIndexOf("\") + 1) & "- 记事本"
                    fstream = New FileStream(filename, FileMode.Create, FileAccess.ReadWrite)
                    sw = New StreamWriter(fstream, System.Text.Encoding.Default)
                    sw.BaseStream.Seek(0, SeekOrigin.End)
                    sw.Write(rtb.Text)
                    sw.Flush()
                Catch ex As Exception
                    MsgBox("保存文件失败")
                Finally
                    sw.Close()
                End Try
            ElseIf result = MsgBoxResult.No Then
                rtb.Text = ""
            End If
        End If
    End If
End Sub
```

## 全局热键

```VB
Public Class Form1
  Public Const WM_HOTKEY = &H312
  Public Const MOD_ALT = &H1
  Public Const MOD_CONTROL = &H2
  Public Const MOD_SHIFT = &H4
  Public Const GWL_WNDPROC = (-4)
  Public Declare Auto Function RegisterHotKey Lib "user32.dll" Alias _
    "RegisterHotKey" (ByVal hwnd As IntPtr, ByVal id As Integer, ByVal fsModifiers As  Integer, ByVal vk As Integer) As Boolean
        
  Public Declare Auto Function UnRegisterHotKey Lib "user32.dll" Alias _
    "UnregisterHotKey" (ByVal hwnd As IntPtr, ByVal id As Integer) As Boolean

  Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
    '注册全局热键
    RegisterHotKey(Handle, 0, MOD_CONTROL, Asc("T")) '第一个热键 Ctrl+T
    RegisterHotKey(Handle, 1, Nothing, Keys.F4) '第二个热键 F4
  End Sub

  Private Sub  Form1_FormClosed(ByVal sender As System.Object, ByVal e As  System.Windows.Forms.FormClosedEventArgs) Handles MyBase.FormClosed
    '注销全局热键
    UnRegisterHotKey(Handle, 0)
    UnRegisterHotKey(Handle, 1)
  End Sub
 
  Protected Overrides Sub WndProc(ByRef m As Message)
    If m.Msg = WM_HOTKEY Then
      MsgBox("在这里添加你要执行的代码", MsgBoxStyle.Information, "全局热键")
    End If
    MyBase.WndProc(m)
  End Sub
End Class
```

## 局部快捷键

```VB
Private Sub Frm_KeyDown(sender As Object, e As KeyEventArgs) Handles Me.KeyDown
        If e.KeyData = (Keys.Control Or Keys.F) Then
            'csControl_Search.Tool_Btn_Find(Me, csXarrayDB, Me.Name, m_strEditStaffCode)
End If
End Sub
```

## 屏蔽系统热键

使用VB.net编写屏蔽热键的方法有很多中,比如说使用系统的API函数,也可以使用钩子来进行屏蔽.还有一种就是.net带的一种方法,首先来判断所按下去的键,然后再执行操作等事件.比如说:

```VB
if (e.keycode==keys.D){e.handle=true}
```

在keydown事件里面处理!这样就可以屏蔽了D键. 实例:

```VB
if  ((Control.ModifierKeys == Keys.Alt)  (e.KeyCode == Keys.F4)){e.Handled = true;}
```

还有一种办法就是不通过屏蔽热键来实现,就是通过设置焦点.你可以把你程序窗口设置为主焦点,这样其他程序一般就无法在你的程序前面了.实现屏蔽的作用.至于任务管理器的话可以通过杀掉进程的办法做到.如下:   

```C#
Process[] p = Process.GetProcesses();
foreach (Process p1  in p){
try{if (p1.ProcessName.ToLower().Trim() == "taskmgr")'这里判断是任务管理器   
{
 p1.Kill();
 return;
 }
 }
 catch{
return;
}
}}
```

以上是使用C#编写的,稍微改下就可以了,在,NET里面都差不多!























































=======
<div align='center'><font size='70'>笔记</font></div>





<font color='red'>红色</font>

<span style='color:blue;background:black;font-size:20;font-family:Oxygen;'>文字</span>

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 数据库

## SQL语言

> `Structured Query Language`一种特殊用途的编程语言，是一种数据库查询和程序设计语言，用于访问数据以及查询、和管理关系数据库系统

### 处理

#### 1. 字段大小写

```sql
UPPER(f_xxxx) -- 大写转换 
LOWER(F_XXXX) -- 小写转换
```

#### 2. 数据类型

`不同平台这两种用法存在差异,如果是编写跨数据库平台的可移植代码最好用CAST();如果是使用 SQL Server,并且需要关于日期格式转换的额外功能，那么CONVERT()可能更合适.`

- ### `CAST(expression AS data_type)`

```sql
-- 语法
SELECT CAST(123 AS VARCHAR(10));  -- 整数转换为字符类型
```

- ### `CONVERT(data_type, expression, [style])`

```sql
-- 语法
SELECT CONVERT(VARCHAR(10), 123); -- 整数转换为字符类型
-- 使用不同的 style 将日期转换为字符串
SELECT CONVERT(VARCHAR, GETDATE(), 112);  -- 输出为 YYYYMMDD
```

#### 3.  文本处理

- `TRIM()`

```sql
-- 删除字符串开始和结束的空格
SELECT TRIM('   OpenAI   ');  -- 结果: 'OpenAI'
```

- `SUBSTRING() or SUBSTR() 取决于具体数据库`

```sql
-- 从字符串中提取子字符串
SELECT SUBSTRING('OpenAI', 2, 4); -- 结果: 'penA'
```

- `CHAR_LENGTH() or 或 LEN`()

```sql
-- 返回字符串的长度
SELECT CHAR_LENGTH('OpenAI');  -- 结果: 6
```

- `CONCAT()`

```sql
-- 连接两个或多个字符串
SELECT CONCAT('Open', 'AI');  -- 结果: 'OpenAI'
```

- `POSITION()`

```sql
-- 在字符串中查找子字符串的位置
SELECT POSITION('pen' IN 'OpenAI');  -- 结果: 2
```

- `REPLACE()`

```sql
-- 替换字符串中的子字符串
SELECT REPLACE('OpenAI', 'AI', 'Source');  -- 结果: 'OpenSource'
```

#### 4.  数值处理

- `ROUND()`

```sql
-- 四舍五入数值
SELECT ROUND(123.4567, 2);  -- 结果: 123.46
```

- `FLOOR()`

```sql
-- 返回小于或等于给定数字的最大整数
SELECT FLOOR(123.4567);  -- 结果: 123
```

- `CEIL() or CEILING()`

```sql
-- 返回大于或等于给定数字的最小整数
SELECT CEILING(123.4567);  -- 结果: 124
```

#### 5. 日期和时间处理

- `CURRENT_DATE()、CURRENT_TIME()、NOW`

```sql
-- 返回当前日期、时间或日期和时间。
SELECT CURRENT_DATE;  -- 结果: 2023-09-06 (假设今天是2023-09-06)
```

- `DATE_PART() or EXTRACT()`

```sql
-- 从日期或时间值中提取部分信息，如年、月、日等
SELECT DATE_PART('YEAR', '2023-09-06');  -- 结果: 2023
```

- `DATE_ADD() or DATE_SUB()`

```sql
-- 为日期添加或减少特定的间隔
SELECT DATE_ADD('2023-09-06', INTERVAL 1 DAY);  -- 结果: 2023-09-07
```

- `例如 MySQL 中使用DATE_FORMAT()  例如 Oracle 和 PostgreSQL 中 使用TO_CHAR() 根据不同数据库进行选择`

```sql
-- 将日期格式化为 YYYY-MM-DD  在SQL Server中
SELECT FORMAT(GETDATE(), 'yyyy-MM-dd') AS FormattedDate;
-- 将日期格式化为 YYYY-MM-DD  在 Oracle, PostgreSQL 中
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') AS FormattedDate FROM DUAL; -- Oracle
SELECT TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD') AS 今天日期;  -- PostgreSQL 今天日期 : 2023-09-06

SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:SS')AS 今天日期; -- pgsql
```

#### 6. 聚合函数

- **SUM**  计算数值列的总和。

```sql
SELECT SUM(column_name) FROM table_name;
```

- **AVG**   计算数值列的灵。

```sql
SELECT AVG(column_name) FROM table_name;
```

- **COUNT**   计算行数。

```sql
SELECT COUNT(column_name) FROM table_name;
```

- **MAX** or **MIN** 返回列中的顶部和简单。

```sql
SELECT MAX(column_name), MIN(column_name) FROM table_name;
```















## 1.递归查询

```sql
--递归查询
-- 定义一个叫做Recursive_CTE的公共表表达式（CTE）
WITH Recursive_CTE AS
(
  -- 基础查询部分
  -- 这部分查询首先选取F_RKNO与我们所给的字符串strRKNO相匹配的记录
  SELECT F_RKNO, F_RKNO_OLD
  FROM dbo.T_CPRKHistory
  WHERE F_RKNO = '{strRKNO}'
  UNION ALL  -- UNION ALL 用于将基础查询的结果和递归查询的结果结合起来
  -- 递归查询部分
  -- 这部分查询选取F_RKNO等于上一次查询结果中的F_RKNO_OLD的记录
  SELECT T.F_RKNO, T.F_RKNO_OLD
  FROM dbo.T_CPRKHistory T
  INNER JOIN Recursive_CTE RC ON T.F_RKNO = RC.F_RKNO_OLD
)
-- 在Recursive_CTE查询的结果中选取符合条件（F_RKNO等于F_RKNO_OLD）的最初的记录
SELECT TOP 1 F_RKNO_OLD 
FROM Recursive_CTE 
WHERE F_RKNO = F_RKNO_OLD;
```

## 2. 根据查询到的数据更改某一字段 重新插入到表内

```sql
INSERT INTO dbo.T_FormStyle_Backup
SELECT '产品发料履历', <其他字段>
FROM dbo.T_FormStyle_Backup
WHERE F_FORMNAME = '压型发料履历'	
```





## 1. `PostgreSQL`

> `PostgreSQL `是一个强大、可靠和灵活的关系型数据库系统，适用于从小型应用到大型企业级应用的各种场景。

`PostgreSQL` 是一种高级的、功能齐全的、开源的关系型数据库管理系统 `RDBMS` 。它起源于加利福尼亚大学伯克利分校，并已经有超过 30 年的开发历史。以下是 `PostgreSQL` 的一些主要特点和优势：

> 1. **开源与社区支持**：PostgreSQL 是一个开源项目，由一个活跃的全球开发社区支持，并且有许多公司提供专业的支持服务。
> 2. **高级功能**：除了基本的 CRUD 操作和 SQL 查询外，PostgreSQL 还支持复杂的数据类型（如 JSON、hstore 和数组）和高级查询功能。
> 3. **可扩展性**：PostgreSQL 允许用户通过添加自定义函数、数据类型和其他扩展来定制其功能。
> 4. **并发与性能**：PostgreSQL 支持多版本并发控制（MVCC），这意味着它可以在多个事务之间有效地处理数据的并发读写操作。
> 5. **安全**：PostgreSQL 提供了多种加密和验证机制，如 SSL 支持、列级权限和基于角色的访问控制。
> 6. **跨平台**：PostgreSQL 可以在多种操作系统上运行，包括 Linux、Windows 和 macOS。
> 7. **数据完整性**：PostgreSQL 支持外键、非空约束、唯一约束和其他数据完整性功能，确保数据的准确性和一致性。
> 8. **备份与恢复**：PostgreSQL 提供了多种数据备份和恢复工具，确保数据的持久性和可用性。
> 9. **SQL 与过程语言**：除了 SQL 外，PostgreSQL 还支持存储过程，并提供了多种过程语言，如 PL/pgSQL、PL/Python、PL/Perl 等。
> 10. **扩展与插件**：有许多第三方插件和工具可以与 PostgreSQL 配合使用，以增强其功能和性能。
> 11. **地理信息系统**：PostgreSQL 与 PostGIS 扩展结合，为地理信息系统（GIS）提供了强大的支持。
> 12. **复制与高可用性**：PostgreSQL 支持多种复制方法，如基于日志的复制和基于触发器的复制，确保数据的高可用性和负载均衡。

Win端 安装参考 [Windows 10平台安装 PostgreSQL 14.2详细教程  alt + 点击进入 ](https://zhuanlan.zhihu.com/p/484450913)

Linux端 安装参考[Linux 上安装  PostgreSQL  alt +点击进入](https://www.runoob.com/postgresql/linux-install-postgresql.html)

### 1. 与 `SqlServer` 区别

1. **数据类型**:

- PostgreSQL 支持 JSON 和 JSONB 数据类型，而 SQL Server 支持 XML 和 JSON 数据类型。
- PostgreSQL 使用 `BYTEA` 类型存储二进制数据，而 SQL Server 使用 `VARBINARY` 或 `IMAGE`。
- PostgreSQL 中的自增字段使用 `SERIAL`，而 SQL Server 使用 `IDENTITY`。

2. **分页**:

- PostgreSQL: `LIMIT 10 OFFSET 20`PostgreSQL： `LIMIT 10 OFFSET 20` 
- SQL Server: `SELECT TOP 10 * FROM table OFFSET 20 ROWS`SQL Server： `SELECT TOP 10 * FROM table OFFSET 20 ROWS` 

3. **字符串连接**:

- PostgreSQL: 使用 `||`PostgreSQL： 使用 `||` 
- SQL Server: 使用 `+`SQL Server： 使用 `+` 

4. **系统函数**:

- 当前日期和时间：PostgreSQL 使用 `NOW()`，而 SQL Server 使用 `GETDATE()`。
- 字符串长度：PostgreSQL 使用 `LENGTH(string)`，而 SQL Server 使用 `LEN(string)`。

5. **变量声明**:

- PostgreSQL: 使用 `DECLARE variable_name TYPE;`，然后使用 `:=` 赋值。
- SQL Server: 使用 `DECLARE @variable_name TYPE`，然后使用 `SET` 赋值。

6. **存储过程**:

- 在 SQL Server 中，常用的是存储过程，使用 `CREATE PROCEDURE` 创建。
- 在 PostgreSQL 11 之前，没有真正的存储过程，但它支持函数，使用 `CREATE FUNCTION` 创建。

7. **临时表**:

- PostgreSQL: 使用 `CREATE TEMP TABLE` 创建临时表。
- SQL Server: 使用 `CREATE TABLE #TableName` 创建临时表。

8. **系统目录**:

- PostgreSQL 使用 `pg_catalog`，而 SQL Server 使用 `sys`。PostgreSQL 使用 ，而 SQL Server 使用 `pg_catalog` `sys` 。

9. **索引**:

- PostgreSQL 支持多种索引类型，如 B-tree、Hash、GiST、SP-GiST、GIN 和 BRIN。
- SQL Server 主要使用 B-tree 结构，但也支持 XML、空间和全文搜索索引。

10. **事务隔离级别**:

- PostgreSQL 支持 Read Committed、Repeatable Read、Serializable 和 Read Uncommitted。
- SQL Server 支持 Read Uncommitted、Read Committed、Repeatable Read、Serializable 和 Snapshot。SQL Server 支持 Read Uncomitted、Read commmitted、Repeatable Read、Serializable 和 snapshot。

**其他特性**:

- PostgreSQL 支持表继承。
- SQL Server 提供了集成的报告服务、分析服务和集成服务。

### 2.     基础用法

**模式（Schemas）**:

- PostgreSQL 使用模式来组织数据库对象，允许多个模式在同一个数据库中。
- SQL Server 的数据库对象是由模式拥有的，但模式主要用作命名空间和权限边界。

**锁**:

- PostgreSQL 使用 MVCC（多版本并发控制）来处理数据并发。
- SQL Server 使用锁和行版本控制。

**ILIKE vs. LIKE**：

- PostgreSQL 的 `ILIKE` 提供了不区分大小写的匹配。
- SQL Server 的 `LIKE` 是默认不区分大小写的，但这取决于服务器的排序规则。

```sql
CREATE SCHEMA dbo; ---创建模式
DROP SCHEMA public CASCADE; ---删除public模式
ALTER SCHEMA pubilc RENAME TO dbo; ---模式重命名
SHOW search_path;   ---默认搜索路径
SET search_path TO dbo;    ---设置默认模式dbo
ALTER USER postgres SET search_path TO dbo; ---更改postgres用户默认模式为dbo
```

#### 1. 检查pgsql数据库编码格式

```sql
SELECT datname, pg_encoding_to_char(encoding) FROM pg_database WHERE datname = 'dbname';
```











## 2.  `SQL Server`

### 1. 查找

#### SQL Server 上查找携带某一字段的表名

```sql
SELECT t.name AS table_name
FROM sys.columns c
JOIN sys.tables t ON c.object_id = t.object_id
WHERE c.name = '字段'
ORDER BY t.name;
```

#### SQL Server 上的内存资源占用

##### 1. 查找内存占用最高的前10个查询

```sql
//查找内存占用最高的前10个查询
SELECT TOP 10
    t.TEXT AS [SQL Text],
    s.execution_count AS [Execution Count],
    s.total_logical_reads AS [Total Logical Reads],
    s.total_logical_reads / s.execution_count AS [Avg Logical Reads],
    s.total_physical_reads AS [Total Physical Reads],
    s.total_physical_reads / s.execution_count AS [Avg Physical Reads],
    s.creation_time AS [Creation Time],
    s.query_hash,
    s.query_plan_hash
FROM sys.dm_exec_query_stats AS s
CROSS APPLY sys.dm_exec_sql_text(s.sql_handle) AS t
ORDER BY s.total_logical_reads DESC;

```

##### 2. 查找内存占用最高的前10个数据库

```sql
//查找内存占用最高的前10个数据库
SELECT TOP 10
    DB_NAME(database_id) AS [Database Name],
    COUNT(*) * 8 / 1024.0 AS [Cached Size (MB)]
FROM sys.dm_os_buffer_descriptors
GROUP BY database_id
ORDER BY [Cached Size (MB)] DESC;
```

##### 3. 内存中占用最高的前10个对象

```sql
//内存中占用最高的前10个对象 显示对象名称、对象ID、对象类型、索引名称、索引ID、分区号、分配单元类型以及缓存大小（MB）
SELECT TOP 10
    o.name AS [Object Name],
    o.object_id AS [Object ID],
    o.type_desc AS [Object Type],
    i.name AS [Index Name],
    i.index_id AS [Index ID],
    p.partition_number AS [Partition Number],
    au.type_desc AS [Allocation Unit Type],
    COUNT(*) * 8 / 1024.0 AS [Cached Size (MB)]
FROM sys.dm_os_buffer_descriptors AS b
JOIN sys.allocation_units AS au ON b.allocation_unit_id = au.allocation_unit_id
JOIN sys.partitions AS p ON (au.type IN (1, 3) AND au.container_id = p.hobt_id) OR (au.type = 2 AND au.container_id = p.partition_id)
JOIN sys.objects AS o ON p.object_id = o.object_id
JOIN sys.indexes AS i ON p.object_id = i.object_id AND p.index_id = i.index_id
WHERE b.database_id = DB_ID()
GROUP BY o.name, o.object_id, o.type_desc, i.name, i.index_id, p.partition_number, au.type_desc
ORDER BY [Cached Size (MB)] DESC;
```



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# *Linux*

<div align='center'><font size='70' color='#0a040f'>Linux</font></div>

> Linux 是一个开源的 Unix-like 操作系统内核，由 Linus Torvalds 于 1991 年首次发布。自那时起，Linux 已被多个团队和组织用于创建完整的操作系统发行版。这些发行版（或称为 "distros"）具有共同的 Linux 内核，但它们的软件、库、用户界面和管理工具各不相同。

## 流行的 Linux 发行版本

### **1. Debian** 

> - 稳定且重视安全。
> - 使用 `.deb` 包格式和 `apt` 包管理工具。
> - 适合服务器和桌面使用。
> - 大量的软件包。

### **2. Ubuntu**

> - 基于 Debian。
> - 用户友好，尤其适合 Linux 初学者。
> - 使用 `.deb` 包格式和 `apt` 包管理工具。
> - 有多个官方衍生版本，如 Ubuntu Server、Ubuntu Desktop、Kubuntu、Xubuntu 等。

### **3. Red Hat Enterprise Linux (RHEL)**

> - 适合企业环境，重视稳定性和安全性。
> - 使用 `.rpm` 包格式和 `yum` 包管理工具。
> - 商业支持和认证。
> - CentOS 是一个 RHEL 的免费克隆，但在 2020 年后转向 CentOS Stream。

### **4. Fedora**

> - RHEL 的上游项目。
> - 提供最新的软件和特性。
> - 使用 `.rpm` 包格式和 `dnf` 包管理工具。

**5. Arch Linux**

> - 简洁、轻量级、滚动发布。
> - 使用 `pacman` 作为包管理工具。
> - 适合中高级用户，需要手动配置很多东西。

### **6. Manjaro**

> - 基于 Arch Linux，但更加用户友好。
> - 提供多种桌面环境选择。
> - 使用 `pacman` 作为包管理工具。

**7. openSUSE**

> - 有两个主要版本：Tumbleweed（滚动发布）和 Leap（定期发布）。
> - 使用 `.rpm` 包格式。
> - YaST 是其独特的系统配置工具。

**8. Gentoo**

> - 源码为基础的发行版。
> - 用户可以为每个软件包设置特定的编译选项。
> - 使用 `emerge` 作为包管理工具。

**9. Slackware**

> - 最古老的发行版本之一。
> - 保持简单的原则。
> - 适合那些喜欢手动管理和配置的用户。

**10. Mint**

> - 基于 Ubuntu。
> - 用户友好，适合初学者。
> - 提供多种桌面环境选择，如 Cinnamon、MATE 和 Xfce。

`每个发行版本都有其独特的特点和用途。选择哪个版本取决于用户的需求、经验和喜好。以上所述发行版不是全部发行版本,仅供参考了解学习~`

## 基础命令

### **1. 文件操作**

- `ls`：列出目录内容

```shell
ls -l
```

- `cd`：改变当前目录  `进入名为 `documents` 的目录：`

```shell
cd documents
```

- `pwd`：显示当前目录

```shell
pwd
```

- `touch`：创建空文件 `创建一个名为 `test.txt` 的文件：`

```shell
touch test.txt
```

- `rm`：删除文件或目录 `删除上面创建的 `test.txt` 文件：`

```shell
rm test.txt
```

- `cp`：复制文件或目录 `复制 file1.txt 到 file2.txt`

```shell
cp file1.txt file2.txt
```

- `mv`：移动或重命名文件或目录  将 `file1.txt` 重命名为 `file3.txt`。

```shell
mv file1.txt file3.txt
```

### **2. 文本处理**

- `cat`：显示文件内容 `显示一个名为 `file.txt` 的文件的内容：`

```shell
cat file.txt
```

- `more` / `less`：分页显示文件内容  more向前浏览，但不允许向后。 less分页显示文本文件的内容。它比 `more` 功能更强大，允许您向前和向后浏览

```shell
more file.txt
less file.txt
```

- `grep`：文本搜索 `从 `file.txt` 中搜索包含 "linux" 的行：`

```shell
grep "linux" file.txt
```

- `sed`：流式文本编辑   在 `file.txt` 中将所有的 "apple" 替换为 "orange"。

```shell
sed 's/apple/orange/g' file.txt
```

- `awk`：文本和数据处理工具 `文本和数据提取和报告工具。它使用一个脚本来处理文件中的数据。`

```shell
awk '{print $2}' data.txt
```

- `cut`：切分文本 `从文件的每行中删除或提取部分。` 从 `data.txt` 中提取第二列的内容（使用冒号作为分隔符）。

```shell
cut -d':' -f2 data.txt
```

### **3. 权限和所有权**

- `chmod`：更改文件权限 `给 `script.sh` 添加执行权限：`

```shell
chmod +x script.sh
```

- `chown`：更改文件所有者 `将 `file.txt` 的所有者更改为 `john`：`

```shell
chown john file.txt
```

- `chgrp`：更改文件所属组 将 `file.txt` 的组更改为 `users`。

```shell
chgrp users file.txt
```

### **4. 网络**

- `ping`：测试网络连接  `ping -t`  连续测试网络连接 

```shell
ping google.com
ping google.com -t
```

- `ifconfig` / `ip`：显示或配置网络接口  `ifconfig/ip`查看所有网络接口的状态

```shell
ifconfig
ip addr
```

- `netstat`：显示网络状态 

```shell
netstat -a
```

- `ssh`：远程登录

```shell
ssh root@192.168.1.10
```

- `scp`：安全复制文件 将 `file.txt` 复制到上述 IP 地址的远程主机上。

```shell
scp file.txt user@192.168.1.10:/path/to/destination
```

- `nslookup` 域名解析 

```shell
nslookup xhbcfszfs.me
```

### **5. 磁盘和系统**

- `df`：显示磁盘使用情况

```shell
df -h
```

- `du`：显示目录或文件大小 `显示 `documents` 目录的大小`

```shell
du -sh documents
```

- `free`：显示内存使用情况

```shell
free -h
```

- `top` / `htop`：显示系统运行状态

```shell
top 
htop
```

### **6. 进程管理**

- `ps`：显示当前进程

```shell
ps aux
```

- `kill`：结束进程 `结束 PID 为 1234 的进程。`

```shell
kill 1234
```

- `pkill`：按名称结束进程  结束所有名为 `firefox` 的进程。

```shell
pkill firefox
```

- `bg`：将进程放到后台运行 如果您在一个进程中（例如 `nano` 编辑器）并按 `Ctrl+Z` 暂停了它，可以使用以下命令将其放到后台：

```shell
bg #放到后台
```

- `fg`：将后台进程放到前台运行

```shell
fg #放到前台
```

### **7. 压缩和备份**

- `tar`：打包和解包文件 将 `directory/` 打包为 `archive.tar.gz`。

```shell
tar czvf archive.tar.gz directory/
```

- `gzip` / `gunzip`：压缩和解压文件

```shell
gzip file.txt #压缩 file.txt。
gunzip file.txt.gz #解压 file.txt.gz。
```

- `zip` / `unzip`：压缩和解压文件

```shell
zip file.zip file.txt #将 file.txt 压缩为 file.zip。
unzip file.zip #解压 file.zip。
```

### **8. 软件和包管理**

- `apt-get`：Debian 和 Ubuntu 的软件包管理   `安装 nano` :

```shell
sudo apt-get install nano
```

- `yum`：RedHat 和 CentOS 的软件包管理 使用 `yum` 安装 `htop`。

```shell
yum install htop
```

- `dnf`：Fedora 的软件包管理 也是新版本的 CentOS 和 RHEL 中的默认包管理器，用于替代 `yum`。

```shell
dnf install htop
```

- `pacman`：Arch Linux 的软件包管理 使用 `pacman` 安装 `htop`。

```shell
pacman -S htop
```

### **9. 系统信息**

- `uname`：显示系统信息 查看完整的系统信息

```shell
uname -a
```

- `hostname`：显示或设置主机名

```shell
hostname
```

- `dmesg`：显示内核消息

```shell
dmesg
```

### **10 .其他**

- `echo`：输出文本或变量

```shell
echo "Hello, World!"
```

- `date`：显示或设置系统日期和时间

```shell
date
```

- `cal`：显示日历 显示当前月份的日历。

```shell
cal
```

- `alias`：创建命令别名 为 `ls -l` 命令创建一个别名 `ll`。

```shell
alias ll="ls -l"
```

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# **Git**

> Git是目前世界上最先进的分布式版本控制系统
>

## `SVN`与`Git`的最主要的区别？

SVN（Subversion）和Git都是版本控制系统，用于跟踪和管理软件项目中的代码变化。它们在一些关键方面有很大的区别：

1. **分布式 vs. 集中式**：
   - Git是分布式版本控制系统，每个开发者都拥有完整的代码仓库副本，可以在本地进行提交、分支创建等操作，然后通过网络同步变更。
   - SVN是集中式版本控制系统，项目有一个中央仓库，开发者需要从中央仓库获取代码，进行修改后再提交回中央仓库。
2. **仓库结构**：
   - Git中的仓库是整个项目的镜像，包含完整的历史记录和分支信息。每个本地仓库都是独立的，可以离线操作。
   - SVN中的仓库是一个中央仓库，开发者只能从中央仓库获取代码，并在提交时需要连接到中央仓库。
3. **速度**：
   - Git通常在本地操作时速度较快，因为大部分操作都在本地仓库进行。
   - SVN的一些操作需要访问网络，可能相对较慢。
4. **分支和合并**：
   - 在Git中，创建分支和合并分支相对较为轻松，开发者可以频繁创建分支来实现不同功能的开发，然后再将分支合并回主线。
   - 在SVN中，分支和合并相对复杂，需要在中央仓库中进行，有时需要手动解决冲突。
5. **历史记录**：
   - Git的历史记录是完整的、分布式的，每个本地仓库都包含完整的历史信息。
   - SVN的历史记录集中在中央仓库中，每个开发者只能看到自己的提交记录和中央仓库的历史。
6. **可用性**：
   - Git可以在没有网络连接的情况下进行工作，因为每个本地仓库都包含完整的代码和历史。
   - SVN需要连接到中央仓库才能获取代码或提交变更。

综上所述，Git更适合分布式团队、需要频繁分支合并和离线工作的场景，而SVN可能更适合相对简单的项目或者集中式团队。选择哪种版本控制系统取决于项目的需求和团队的工作流程。
<details>
    <summary>通俗来讲区别</summary>
<pre>
<text>
SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。
Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
</text>
</pre>
</details>
工作原理及其流程:

![img](https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_720w.webp)

## 基本常用动作

### 1. 提交代码动作

```xml
//git status  查看当前状态
//git add .  或者 git add xxx 一个提交全部 一个提交指定
//git commit -m "提交代码" 推送修改到本地git库中
//git pull <远程主机名> <远程分支名> 取回远程主机某个分支的更新，再与本地的指定分支合并。
//git push <远程主机名> <远程分支名>  把当前提交到git本地仓库的代码推送到远程主机的某个远程分之上
```

### 2. 设置分支链接

```yaml
// git remote get-url origin  查看当前分支的链接

// git remote set-url origin newUrl 设置当前分支的链接
```

### 3. 远程仓库覆盖本地

```yaml
# 拉取所有更新，不同步；
git fetch --all

# 本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；
git reset --hard origin/master

# 再更新一次（其实也可以不用，第二步命令做过了其实）
git pull
```

*以上三条语句可合并成一条语句执行*

```yaml
git fetch --all && git reset --hard origin/master && git pull
```

### 4. 更改Git连接

1. 使用以下命令查看当前的远程仓库连接：

```xm
git remote -v
```

2. 使用以下命令移除当前的远程仓库连接：

```xm
git remote remove origin
```

3. 使用以下命令添加新的远程仓库连接：

```xml
git remote add origin <新的Git连接>
```

4. 使用以下命令验证新的远程仓库连接是否成功添加：

```xml
git remote -v
```

### 5. 设置SSH Key连接

```xml
git remote set-url origin <ssh连接>
```









---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------







# Vue 

`尤雨溪 独立开源软件开发者 twitter : @yuxiyou`

## **Vue.js 基础**

1. **核心概念**：Vue基于MVVM模式（Model-View-ViewModel），将用户界面分为视图、模型和ViewModel三部分，通过双向绑定实现数据的动态更新。
2. **指令**：Vue提供了一系列指令，如`v-bind`用于属性绑定，`v-model`用于双向绑定，`v-for`用于循环渲染等。
3. **模板语法**：Vue使用类似HTML的模板语法，通过插值和指令实现动态数据绑定。
4. **组件**：Vue允许将应用拆分为可重用的组件，每个组件包含自己的模板、逻辑和样式。
5. **生命周期钩子**：Vue组件具有一系列的生命周期钩子函数，允许在组件创建、更新和销毁等阶段执行自定义逻辑。

## **Vue 2 / 3 区别**

1. **性能优化**：Vue 3在虚拟DOM的实现上进行了优化，提升了渲染性能。它引入了基于Proxy的响应式系统，比Vue 2中的Object.defineProperty更高效。
2. **Composition API**：Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式，允许将相关逻辑组合成自定义的逻辑组合函数，提高了代码的可维护性。
3. **Teleport**：Vue 3引入了Teleport组件，允许将组件的内容渲染到DOM中的任何位置，而不受组件层次结构的限制。
4. **Fragment**：Vue 3中可以使用Fragment（<template>）包裹多个元素，而不必添加额外的父元素。
5. **全局API修改**：一些全局API在Vue 3中发生了变化，例如`v-bind`改为`v-model`的属性绑定功能，`v-on`改为`@`等。
6. **Tree-Shaking支持**：Vue 3更好地支持Tree-Shaking，使得只引入使用的代码，减小最终构建的大小。

## **ES6中的 const  var  let** 

### 1.作用域区别

```javascript
//var 声明的变量的作用域只能是全局或者整个函数块的。 使用var声明的变量会被提升到其作用域的顶部，在代码中可以在声明之前访问。
//let 声明的变量的作用域则是它当前所处代码块. let声明的变量不会被提升，只能在声明之后使用。
function Test() {
  var a = 1;
  let b = 1;
  {
  var a = 2; 
  let b = 2; 
  console.log(a); // 2
  console.log(b); // 2
  }
  console.log(a); // 2 var变量是全局的
  console.log(b); // 1 let变量只会影响当前区域
}
//let 声明的变量的作用域可以比 var 声明的变量的作用域有更小的限定范围，更具灵活。
```

### 2.**重复声明**

```javascript
//var 允许在同一作用域中重复声明，而 let 不允许在同一作用域中重复声明，否则将抛出异常。
function test() {
  var a = 3;
  var a = 4;
    
  let b = 1;
  let b = 2; 
    
  console.log(a) // 4
  console.log(b) // SyntaxError: Identifier 'b' has already been declared
}
//let 声明的重复性检查是发生在词法分析阶段，也就是在代码正式开始执行之前就会进行检查。
```

### 3.**绑定全局对象**

```javascript
//var 在全局环境声明变量，会在全局对象里新建一个属性，而 let 在全局环境声明变量，则不会在全局对象里新建一个属性。
var foo = 'global'
let bar = 'global'

console.log(this.foo) // global
console.log(this.bar) // undefined
//let 在全局环境声明变量 bar 保存在[[Scopes]][0]: Script这个变量对象的属性中，而[[Scopes]][1]: Global就是我们常说的全局对象。
```

### 4.**变量提升与暂存死区**

```javascript
console.log(a) // undefined
var a = 1;
console.log(a) // 1
```

```js
console.log(bar); // undefined 不存在
console.log(foo); // ReferenceError: foo is not defined 存在但是未定义
var bar = 1;
let foo = 2;
```

### **5. Const**

```js
//ES6引入的关键字(let const)
// const用于声明常量。与let类似，const也具有块级作用域，并且不会被提升。一旦用const声明一个变量，它的值就不能被修改，并且必须在声明时进行初始化。
function example() {
  if (true) {
    const x = 10;
    console.log(x); // 10
    x = 20; // Error: Assignment to constant variable
  }
```

### **6. 总结区别**

- 使用`var`声明的变量具有函数作用域，可以在整个函数内部访问。
- 使用`let`声明的变量具有块级作用域，只能在声明的块内部访问。
- 使用`const`声明的变量也具有块级作用域，且其值不能被修改。

推荐使用`let`和`const`来声明变量，而尽量避免使用`var`，以避免潜在的作用域问题和变量提升带来的困惑。

## Vue 2 生命周期钩子

### 1. 创建阶段

1. `beforeCreate`: 在实例被创建之前调用，此时组件的数据观测和事件机制尚未初始化。
2. `created`: 在实例创建完成后调用，此时已完成数据观测，可以访问数据、计算属性、方法和侦听器，但尚未挂载到DOM。

### 2. 挂载阶段

1. `beforeMount`: 在挂载开始之前调用，此时模板编译已完成，但尚未将模板渲染到DOM中。
2. `mounted`: 在挂载完成后调用，此时组件已经被挂载到DOM中，可以操作DOM节点。

### 3. 更新阶段

1. `beforeUpdate`: 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在此修改数据。
2. `updated`: 在数据更新之后调用，发生在虚拟DOM重新渲染和打补丁之后，可以操作更新后的DOM。

### 4. 销毁阶段

1. `beforeDestroy`: 在实例销毁之前调用，此时实例仍然完全可用。
2. `destroyed`: 在实例销毁之后调用，此时Vue实例的所有指令都已解绑，事件监听器已被移除，子实例也被销毁。

### 5. 激活与停用阶段

1. `activated `(仅`keep-alive`组件): 在组件被激活时调用。
2. `deactivated `(仅`keep-alive`组件): 在组件被停用时调用。

## Vue 3 生命周期钩子

Vue 3中的生命周期钩子函数有所变化，并引入了新的API。

### 1. 创建阶段

1. `beforeCreate`: 在实例被创建之前调用。
2. `created`: 在实例创建完成后调用，此时已完成数据观测，可以访问数据、计算属性、方法和侦听器，但尚未挂载到DOM。
3. `onBeforeMount`: 在挂载开始之前调用。
4. `onMounted`: 在挂载完成后调用，此时组件已经被挂载到DOM中，可以操作DOM节点。

### 2. 更新阶段

1. `onBeforeUpdate`: 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在此修改数据。
2. `onUpdated`: 在数据更新之后调用，发生在虚拟DOM重新渲染和打补丁之后，可以操作更新后的DOM。

### 3. 销毁阶段

1. `onBeforeUnmount`: 在实例销毁之前调用，此时实例仍然完全可用。
2. `onUnmounted`: 在实例销毁之后调用，此时Vue实例的所有指令都已解绑，事件监听器已被移除，子实例也被销毁。

### 4. 组件状态更新阶段

1. `onActivated `(仅`<keep-alive>`组件): 在组件被激活时调用。
2. `onDeactivated `(仅`<keep-alive>`组件): 在组件被停用时调用。

## 核心特性和API

### 1. ` computed`

`computed`属性用于定义`计算属性`，它会根据响应式数据的变化自动更新计算结果。在Vue组件中，你可以使用`computed`选项来定义计算属性。

`computed`方法在Vue 2和Vue 3中都存在，但在Vue 3中有一些语法上的变化：

在Vue 2中，计算属性和观察者的定义使用对象字面量的形式，例如：

```js
// Vue 2的计算属性
computed: {
  fullName: function() {
    return this.firstName + ' ' + this.lastName;
  }
},
```

而在Vue 3中，计算属性的定义使用函数的形式，例如：

```js
// Vue 3的计算属性
computed: {
  fullName() {
    return this.firstName + ' ' + this.lastName;
  }
},
```

### 2.  `watch`

`watch`属性用于 `观察响应式数据 `的变化，并在数据变化时执行相应的回调函数。你可以通过`watch`选项来定义一个或多个观察者。

`watch`方法在Vue 2和Vue 3中都存在，但在Vue 3中有一些语法上的变化：

```js
// Vue 2的观察者
watch: {
  firstName: function(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  },
  lastName: function(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  }
}
```

Vue 3中，观察者的定义使用函数的形式，例如：

```js
// Vue 3的观察者
watch: {
  firstName(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  },
  lastName(newValue, oldValue) {
    // 处理数据变化的回调逻辑
  }
}
```

除了生命周期钩子函数以外，Vue 2和Vue 3还提供了其他一些常用的方法，用于操作组件、数据和DOM等。以下是一些常见的方法：

### 3.  `methods`

`methods`选项用于定义组件中的方法。这些方法可以在组件的模板中被调用，也可以在组件的其他方法中使用。

```js
//在Vue 2中：
export default {
  methods: {
    handleClick() {
      // 处理点击事件的逻辑
    }
  }
}
```

```js
//在Vue 3中：
import { ref } from 'vue';
export default {
  setup() {
    const handleClick = () => {
      // 处理点击事件的逻辑
    };
    return {
      handleClick
    };
  }
}
```

### 4. `data`

`data`选项用于定义组件的数据。你可以在`data`中声明组件的响应式数据，并在组件的模板和方法中使用。

在Vue 2中，可以使用`data`选项来定义组件的数据。例如：

```js
export default {
  data() {
    return {
      message: 'Hello, Vue!'
    };
  }
}
```

而在Vue 3中，使用`data`选项被弃用，推荐使用`setup`函数和响应式数据对象。例如：

```js
import { reactive } from 'vue';

export default {
  setup() {
    const data = reactive({
      message: 'Hello, Vue!'
    });

    return {
      data
    };
  }
}
```

### 5. `props`

`props`选项用于定义组件的属性。通过`props`，父组件可以向子组件传递数据，子组件可以接收和使用这些数据。

在Vue 2和Vue 3中，可以通过`props`选项来定义组件的属性。例如，在Vue 2和Vue 3中：

```js
export default {
  props: ['title']
}
```

### 6.  `$emit`

`$emit`是一个实例方法，用于触发当前组件实例上的自定义事件。通过`$emit`方法，你可以在子组件中向父组件发送自定义事件，并传递数据。

在组件实例中，可以使用`$emit`方法来触发自定义事件。例如，在Vue 2和Vue 3中：

```js
// 触发自定义事件
this.$emit('my-event', eventData);
```

### 7. `$refs`

`$refs`是一个实例属性，用于在组件中访问子组件或DOM元素。通过给组件或DOM元素添加`ref`属性，你可以通过`$refs`来引用它们。

在组件实例中，可以通过`$refs`属性来访问子组件或DOM元素。例如，在Vue 2和Vue 3中：

```js
// 访问子组件或DOM元素
this.$refs.myComponent  // 子组件的引用
this.$refs.myElement   // DOM元素的引用
```

### 8.  `$nextTick`

`$nextTick`是一个实例方法，用于在下次DOM更新循环结束之后执行回调函数。它可以在DOM更新后执行一些操作，例如访问更新后的DOM元素。

```js
// 在下次DOM更新循环结束后执行回调函数
this.$nextTick(() => {
  // 在DOM更新后执行的操作
});
```

### 9. `v-on` `@`

`v-on（或简写为 @ ）`是一个指令，用于监听DOM事件，并在事件触发时执行相应的方法。通过`v-on`，你可以绑定事件监听器到DOM元素上。

```js
<!-- 监听点击事件 -->
<button v-on:click="handleClick">Click Me</button>

<!-- 使用简写语法 -->
<button @click="handleClick">Click Me</button>

```

### 10.  `v-bind`  `:`

`v-bind（或简写为 : ）` 是一个指令，用于动态地绑定HTML属性或组件的属性。通过`v-bind`，你可以将数据绑定到组件或DOM元素的属性上。

```js
<!-- 动态绑定属性 -->
<div v-bind:class="{'red': isRed}"></div>

<!-- 使用简写语法 -->
<div :class="{'red': isRed}"></div>
```

### 11. `v-for`

`v-for`是一个指令，用于渲染列表数据。通过`v-for`，你可以根据数据循环渲染DOM元素或组件。

```js
<!-- 渲染列表 -->
<ul>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>
```

### 12. `v-if`

`v-if`是一个指令，用于条件性地渲染DOM元素或组件。通过`v-if`，你可以根据条件判断来决定是否渲染特定的元素或组件。

```js
<!-- 条件渲染 -->
<div v-if="isVisible">Visible</div>
```



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# DataV

```js
<dv-loading>Loading...</dv-loading>  -- 显示加载组件
```

















































# **VB.NET**

## 基本使用

### 1. 类型转换

```vb
Convert.ToDecimal(Row("F_xxxx")) '举例将字符转换成数字
```

### 2. 截取字符串

```vb
Row("F_BQXLH").ToString().Substring(0, 2) = "RK" '截取前两位判断
```

### 3. 获取C1ComboBox1的下拉取值

```vb
 ' 获取选中的线体信息作为下拉框值
Dim selectedStrval As String = C1ComboBox1.SelectedItem.ToString()
```

### 4. 删除选中

```vb
    Private Sub Button4_Click(sender As Object, e As EventArgs) Handles Button4.Click
        Dim selectedRows As DataRow() = CType(C1FlexGrid1.DataSource, DataTable).Select($"F_DEL={True}")
        If selectedRows.Length > 0 Then
            Dim result As DialogResult = MessageBox.Show($"确定要删除选中的 {selectedRows.Count} 条记录吗？", "确认删除", MessageBoxButtons.YesNo, MessageBoxIcon.Question)
            If result = DialogResult.Yes Then
                Dim dataTable As DataTable = CType(C1FlexGrid1.DataSource, DataTable)
                For Each row In selectedRows
                    dataTable.Rows.Remove(row)
                Next
            End If
        Else
            MessageBox.Show("请勾选要删除的记录！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
        End If
    End Sub
```

### 5. 全选反选

```vb
    '全选 反选
    Private Sub Button3_Click(sender As Object, e As EventArgs) Handles Button3.Click
        ' 检查C1FlexGrid1是否有数据
        If csDatatableC1 IsNot Nothing AndAlso csDatatableC1.Rows.Count > 0 Then
            ' 检查当前按钮文本，执行全选或取消操作
            If Button3.Text = "全选" Then
                For Each row As DataRow In csDatatableC1.Rows
                    row("F_DEL") = True
                Next
                Button3.Text = "反选"
            ElseIf Button3.Text = "反选" Then
                For Each row As DataRow In csDatatableC1.Rows
                    row("F_DEL") = False
                Next
                Button3.Text = "全选"
            End If
            ' 刷新C1FlexGrid1显示
            C1FlexGrid1.Refresh()
        Else
            MessageBox.Show("当前没有数据无法选中,请确认！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
        End If
    End Sub
```

### 6. 禁用以及隐藏

```vb
'禁用
Private Sub RadioButton1_CheckedChanged(sender As Object, e As EventArgs) Handles RadioButton1.CheckedChanged
    If RadioButton1.Checked Then
        ' RadioButton1被选中时的操作
        RadioButton6.Enabled = False ' 禁用RadioButton6
        RadioButton7.Enabled = False ' 禁用RadioButton7
        RadioButton8.Enabled = False ' 禁用RadioButton8
    Else
        ' RadioButton1未被选中时的操作
        RadioButton6.Enabled = True ' 恢复RadioButton6的可用性
        RadioButton7.Enabled = True ' 恢复RadioButton7的可用性
        RadioButton8.Enabled = True ' 恢复RadioButton8的可用性
    End If
End Sub
'如果你想要隐藏RadioButton6、RadioButton7和RadioButton8，可以将Enabled属性替换为Visible属性，并将其设置为False来隐藏它们。
Private Sub RadioButton1_CheckedChanged(sender As Object, e As EventArgs) Handles RadioButton1.CheckedChanged
    If RadioButton1.Checked Then
        ' RadioButton1被选中时的操作
        RadioButton6.Visible = False ' 隐藏RadioButton6
        RadioButton7.Visible = False ' 隐藏RadioButton7
        RadioButton8.Visible = False ' 隐藏RadioButton8
    Else
        ' RadioButton1未被选中时的操作
        RadioButton6.Visible = True ' 恢复RadioButton6的可见性
        RadioButton7.Visible = True ' 恢复RadioButton7的可见性
        RadioButton8.Visible = True ' 恢复RadioButton8的可见性
    End If
End Sub
```

### 7.  提示窗口弹出

#### 1.  可关闭提示框

```vb
MessageBox.Show("当前没有数据无法选中,请确认！", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error)
```

#### 2. 不可关闭提示框

```vb
'某一窗体关闭的提示确认框!     
Private Sub Frm_Main_FormClosing(sender As Object, e As FormClosingEventArgs) Handles Me.FormClosing

        Dim bolEnable As Boolean = False
        If MessageBox.Show("xxx软件确定关闭吗？", Me.Text, MessageBoxButtons.YesNo, MessageBoxIcon.Question) = DialogResult.No Then
            e.Cancel = True'窗体仍然不会关闭
        Else
            Using csFrm_PassWord As New Frm_CloseEnter
                If csFrm_PassWord.ShowDialog = DialogResult.OK Then
                Else
                    e.Cancel = True'窗体仍然不会关闭
                End If
            End Using
        End If
    End Sub
```

#### 3. 输入提示框

```vb
Dim result As String = InputBox("请输入您要输入的：")
```

#### 4. 颜色选择提示框

```vb
Dim colorDialog As New ColorDialog()
colorDialog.ShowDialog()
Dim selectedColor As Color = colorDialog.Color
```







### 8.  位运算符 

1. `And` - 位与操作。如果两位都为 1，则结果为 1，否则结果为 0。

   例如：`5 And 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 And 3` 的结果是 1。

2. `Or` - 位或操作。如果两位中至少有一位为 1，则结果为 1，否则结果为 0。

   例如：`5 Or 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 Or 3` 的结果是 7。

3. `Xor` - 位异或操作。如果两位不相同，则结果为 1，否则结果为 0。

   例如：`5 Xor 3`，因为 5 是 101（二进制），3 是 11（二进制），所以 `5 Xor 3` 的结果是 6。

4. `Not` - 位非操作。对每一位进行取反。

   例如：`Not 5`，因为 5 是 101（二进制），取反后得到 010（二进制），结果是 2。

5. `<<` - 左移操作符。将位向左移动指定的位数。例如，`5 << 2`将数字5（101二进制）向左移动2位，结果是20（10100二进制）。

6. `>>` - 右移操作符。将位向右移动指定的位数。例如，`20 >> 2`将数字20（10100二进制）向右移动2位，结果是5（101二进制）。

这些运算符在处理二进制数据，尤其是在底层编程、网络编程和图形编程等方面非常有用。

### 9  逻辑运算符

逻辑运算符在 VB.NET 中用于执行逻辑运算，比如 `And`、`Or`、`Not`、`IsTrue`、`IsFalse`、`AndAlso` 和 `OrElse`。

1. `AndAlso`：也称为逻辑与操作符。它会先计算第一个操作数，如果第一个操作数为 False，那么就不会计算第二个操作数，因为无论第二个操作数的值是什么，结果都是 False。这种现象称为短路行为。

2. `OrElse`：也称为逻辑或操作符。如果第一个操作数为 True，则不会计算第二个操作数，因为无论第二个操作数的值是什么，结果都是 True。这也是一种短路行为。
3. `And`：逻辑与运算符。如果两个操作数都为 True，那么结果为 True，否则结果为 False。与 `AndAlso` 不同，它不具备短路行为，即它总是会评估两个操作数。
4. `Or`：逻辑或运算符。如果两个操作数中至少有一个为 True，那么结果为 True，否则结果为 False。与 `OrElse` 不同，它不具备短路行为，即它总是会评估两个操作数。
5. `Not`：逻辑非运算符。如果操作数为 True，那么结果为 False，如果操作数为 False，那么结果为 True。
6. `IsTrue` 和 `IsFalse`：这些运算符用于确定一个表达式是否返回 True 或 False。但是，一般来说，我们更常用的是 `=` 运算符来进行布尔比较，比如 `If a = True Then`。

































## 1.窗体关闭事件

一般来说都是this.close(); 方法调用一下就可以了。

这像是以前 VB 的写法，VB.net 里不是这样的，应该是：

```vb
Private Sub Form_Closed(ByVal sender As Object, ByVal e As System.EventArgs) Handles MyBase.Closed
MagBox("1111")
End Sub '注意，... Handles MyBase.Closed 是在同一行里的。
```

## 2.  窗体的所有事件

|                      名称                      |                             说明                             |
| :--------------------------------------------: | :----------------------------------------------------------: |
|                 Activated激活                  |             当使用代码激活或用户激活窗体时发生。             |
|       AutoSizeChanged自动调整大小已更改        |                 当 AutoSize 属性更改时发生。                 |
|       AutoValidateChanged自动验证已更改        |               当 AutoValidate 属性更改时发生。               |
|         BackColorChanged背面颜色已更改         |    当 BackColor 属性的值更改时发生。（从 Control 继承。）    |
|      BackgroundImageChanged背景图像已更改      | 当 BackgroundImage 属性的值更改时发生。（从 Control 继承。） |
| BackgroundImageLayoutChanged背景图像布局已更改 | 当 BackgroundImageLayout 属性更改时发生。（从 Control 继承。） |
|     BindingContextChanged绑定上下文已更改      | 当 BindingContext 属性的值更改时发生。（从 Control 继承。）  |
|     CausesValidationChanged原因验证已更改      | 当 CausesValidation 属性的值更改时发生。（从 Control 继承。） |
|            ChangeUICues更改用户界面            | 焦点或键盘用户界面 (UI) 提示更改时发生。（从 Control 继承。） |
|                   Click点击                    |           在单击控件时发生。（从 Control 继承。）            |
|       ClientSizeChanged客户端大小已更改        |   当 ClientSize 属性的值更改时发生。（从 Control 继承。）    |
|                    Closed闭                    |                       关闭窗体时发生。                       |
|                  Closing关闭                   |                       关闭窗体时发生。                       |
|       ContextMenuChanged上下文菜单已更改       |   当 ContextMenu 属性的值更改时发生。（从 Control 继承。）   |
|   ContextMenuStripChanged上下文菜单条已更改    | 当 ContextMenuStrip 属性的值更改时发生。（从 Control 继承。） |
|             ControlAdded控件已添加             | 在将新控件添加到 Control.ControlCollection 时发生。（从 Control 继承。） |
|            ControlRemoved控件已删除            | 在从 Control.ControlCollection 移除控件时发生。（从 Control 继承。） |
|            CursorChanged光标已更改             |     当 Cursor 属性的值更改时发生。（从 Control 继承。）      |
|                 Deactivate关闭                 |            当窗体失去焦点并不再是活动窗体时发生。            |
|                  Disposed处置                  | 当通过调用 Dispose 方法释放组件时发生。（从 Component 继承。） |
|             DockChanged坞站已更改              |      当 Dock 属性的值更改时发生。（从 Control 继承。）       |
|                DoubleClick双击                 |           在双击控件时发生。（从 Control 继承。）            |
|                  DragDrop拖放                  |          拖放操作完成时发生。（从 Control 继承。）           |
|               DragEnter拖动输入                |     在将对象拖入控件的边界时发生。（从 Control 继承。）      |
|               DragLeave拖拽离开                |      将对象拖出控件的边界时发生。（从 Control 继承。）       |
|                  DragOver拖拽                  |     在将对象拖到控件的边界上发生。（从 Control 继承。）      |
|           EnabledChanged已启用已更改           |      在 Enabled 属性值更改后发生。（从 Control 继承。）      |
|                   Enter进入                    |            进入控件时发生。（从 Control 继承。）             |
|             FontChanged字体已更改              |       在 Font 属性值更改时发生。（从 Control 继承。）        |
|           ForeColorChanged前色已更改           |     在 ForeColor 属性值更改时发生。（从 Control 继承。）     |
|              FormClosed表单已关闭              |                       关闭窗体后发生。                       |
|              FormClosing表单关闭               |                       关闭窗体前发生。                       |
|              GiveFeedback给予反馈              |        在执行拖动操作期间发生。（从 Control 继承。）         |
|                GotFocus得到焦点                |         在控件接收焦点时发生。（从 Control 继承。）          |
|             HandleCreated句柄创建              |        在为控件创建句柄时发生。（从 Control 继承。）         |
|           HandleDestroyed句柄已销毁            |   在控件的句柄处于销毁过程中时发生。（从 Control 继承。）    |
|        HelpButtonClicked帮助按钮已点击         |                    单击“帮助”按钮时发生。                    |
|           HelpRequested已请求的帮助            |        用户请求控件帮助时发生。（从 Control 继承。）         |
|          ImeModeChanged图像模式已更改          |       在 ImeMode 属性更改后发生。（从 Control 继承。）       |
|       InputLanguageChanged输入语言已更改       |                  更改窗体的输入语言后发生。                  |
|       InputLanguageChanging输入语言更改        |             当用户尝试更改窗体的输入语言时发生。             |
|                Invalidated失效                 |     控件的显示要求重新绘制时发生。（从 Control 继承。）      |
|                 KeyDown键向下                  |   在控件有焦点的情况下按下键时发生。（从 Control 继承。）    |
|                  KeyPress按键                  | 在控件有焦点的情况下字符、空格或退格键时发生。（从 Control 继承。） |
|                   KeyUp键控                    |   在控件有焦点的情况下释放键时发生。（从 Control 继承。）    |
|                   Layout布局                   |    在控件应重新定位其子控件时发生。（从 Control 继承。）     |
|                   Leave离开                    |       在输入焦点离开控件时发生。（从 Control 继承。）        |
|                    Load负荷                    |                   在第一次显示窗体前发生。                   |
|           LocationChanged位置已更改            |     在 Location 属性值更改后发生。（从 Control 继承。）      |
|                 LostFocus失焦                  |         在控件失去焦点时发生。（从 Control 继承。）          |
|            MarginChanged边距已更改             |                  当 Margin 属性更改时发生。                  |
|     MaximizedBoundsChanged最大化边界已更改     |           在 MaximizedBounds 属性的值更改后发生。            |
|        MaximumSizeChanged最大大小已更改        |             在 MaximumSize 属性的值更改后发生。              |
|        MdiChildActivateMdiChildActivate        |  在多文档界面 (MDI) 应用程序内激活或关闭 MDI 子窗体时发生。  |
|              MenuComplete菜单完成              |                  当窗体菜单失去焦点时发生。                  |
|               MenuStart菜单开始                |                  当窗体菜单接收焦点时发生。                  |
|        MinimumSizeChanged最小大小已更改        |             在 MinimumSize 属性的值更改后发生。              |
|       MouseCaptureChanged鼠标捕获已更改        |       当控件失去鼠标捕获时发生。（从 Control 继承。）        |
|               MouseClick鼠标点击               |         用鼠标单击控件时发生。（从 Control 继承。）          |
|            MouseDoubleClick鼠标双击            |         用鼠标双击控件时发生。（从 Control 继承。）          |
|               MouseDown鼠标向下                | 当鼠标指针位于控件上并按下鼠标键时发生。（从 Control 继承。） |
|               MouseEnter鼠标输入               |       在鼠标指针进入控件时发生。（从 Control 继承。）        |
|               MouseHover鼠标悬停               |     在鼠标指针停放在控件上时发生。（从 Control 继承。）      |
|               MouseLeave鼠标离开               |       在鼠标指针离开控件时发生。（从 Control 继承。）        |
|               MouseMove鼠标移动                |      在鼠标指针移到控件上时发生。（从 Control 继承。）       |
|                MouseUp鼠标向上                 | 在鼠标指针在控件上并释放鼠标键时发生。（从 Control 继承。）  |
|               MouseWheel鼠标滚轮               |    在控件有焦点且鼠标轮移动时发生。（从 Control 继承。）     |
|                    Move移动                    |           在移动控件时发生。（从 Control 继承。）            |
|            PaddingChanged填充已更改            |        在控件空白区更改时发生。（从 Control 继承。）         |
|                    Paint漆                     |           在重绘控件时发生。（从 Control 继承。）            |
|               ParentChanged父改                |      在 Parent 属性值更改时发生。（从 Control 继承。）       |
|            PreviewKeyDown预览键向下            | 在焦点位于此控件上的情况下，当有按键动作时发生（在 KeyDown 事件之前发生）。（从Control 继承。） |
|     QueryAccessibilityHelp查询辅助功能帮助     | 在 AccessibleObject 为辅助功能应用程序提供帮助时发生。（从 Control 继承。） |
|         QueryContinueDrag查询继续拖动          | 在拖放操作期间发生，并且允许拖动源确定是否应取消拖放操作。（从 Control 继承。） |
|            RegionChanged区域已更改             |     当 Region 属性的值更改时发生。（从 Control 继承。）      |
|                   Resize调整                   |         在调整控件大小时发生。（从 Control 继承。）          |
|            ResizeBegin调整大小开始             |                 窗体进入大小调整模式时发生。                 |
|             ResizeEnd调整大小结束              |                 窗体退出大小调整模式时发生。                 |
|         RightToLeftChanged从右到左更改         |    在 RightToLeft 属性值更改时发生。（从 Control 继承。）    |
|   RightToLeftLayoutChanged从右到左布局已更改   |           更改 RightToLeftLayout 属性值之后发生。            |
|                   Scroll滚动                   |                 用户或代码滚动工作区时发生。                 |
|             SizeChanged大小已更改              |       在 Size 属性值更改时发生。（从 Control 继承。）        |
|             StyleChanged风格已更改             |                    当窗体样式更改时发生。                    |
|       SystemColorsChanged系统颜色已更改        |                     显示设置更改时发生。                     |
|        TabIndexChanged选项卡索引已更改         |     当 TabIndex 属性值更改时发生。（从 Control 继承。）      |
|          TabStopChangedTabStopChanged          |      当 TabStop 属性值更改时发生。（从 Control 继承。）      |
|             TextChanged文本已更改              |       在 Text 属性值更改时发生。（从 Control 继承。）        |
|                 Validated验证                  |        在验证控件的内容时发生。（从 Control 继承。）         |
|                 Validating验证                 |           在验证控件时发生。（从 Control 继承。）            |
|            VisibleChanged可见已更改            |      在 Visible 属性值更改时发生。（从 Control 继承。）      |
|                 VScrollVScroll                 |        在垂直滚动条滚动时发生。（从 Control 继承。）         |

## 3. vb命令按钮退出怎么设置？

在退出按钮的Click事件中用Unload Me就可以关闭窗体。

```vb
Private Sub Command1_Click()
Unload Me
End Sub
```

答案补充 :

代码就是我回答那些了，双击按钮把代码输入进去就行了。对了，你的是VB6还是VB.Net啊？VB6就是用Unload Me，如果是VB.Net应该用Me.Close()。

```vb
'这个是VB.Net的代码：

Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button2.Click
Me.Close()
End Sub
```

## 窗体关闭事件

直接上代码:

```vb
Private Sub Form1_FormClosing(ByVal sender As System.Object, ByVal e As System.Windows.Forms.FormClosingEventArgs) 
MsgBox("窗口即将关闭....") 
End Sub
Else 
  e.Cancel = True 
End If
```

## 窗体的退出事件 vb.net

既然是VB.NET，那么，窗体关闭的事件，是.net framework提供的，是FormClosed事件。也是两个参数，一个object sender这个是object基类，整个.net framework都是从它派生的，一个 EventArgs  e，事件处理基类，一切事件是从EventArgs基类派生出来的。

## vb.net窗体关闭的问题

```VB
Private Sub frmNotepad_Closing(ByVal sender As Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing
    Call subexit()
End Sub

Sub subexit()
    Dim frmNew As frmNotepad
    frmNew = ActiveForm

    If frmNew.Text = "未定标题 - 记事本" Then
        If frmNew.rtb.Text = "" Then
        Else
            Dim result As New MsgBoxResult 'result提示对话框yes,no,cancel
            result = MsgBox("未定标题文件的文字已经改变。" & Chr(10) & Chr(10) & "想保存文件吗？", MsgBoxStyle.YesNoCancel + MsgBoxStyle.Exclamation, "记事本")

            If result = MsgBoxResult.Yes Then 'result.Yes表示保存，清空内容，打开新页面
                Dim fileSave As New SaveFileDialog
                Dim re As New DialogResult 're提示对话框OK，cancel

                fileSave.FileName = "*.txt"
                fileSave.Filter = "文本文档(*.txt)|*.txt|所有文件|*.*"
                re = fileSave.ShowDialog()

                If re = DialogResult.OK Then 're.OK表示成功保存，清空内容，打开新页面
                    filename = fileSave.FileName
                    Dim fstream As FileStream
                    Dim sw As StreamWriter

                    Try
                        'frmNew.Text = filename.Substring(filename.LastIndexOf("\") + 1) & "- 记事本"
                        fstream = New FileStream(filename, FileMode.Create, FileAccess.ReadWrite)
                        sw = New StreamWriter(fstream, System.Text.Encoding.Default)
                        sw.BaseStream.Seek(0, SeekOrigin.End)
                        sw.Write(rtb.Text)
                        sw.Flush()
                    Catch ex As Exception
                        MsgBox("保存文件失败")
                    Finally
                        sw.Close()
                    End Try
                ElseIf re = DialogResult.Cancel Then 're.cancel表示不保存，不改变任何结果
                End If
            ElseIf result = MsgBoxResult.No Then 'result.no表示不保存，清空内容
                rtb.Text = ""
            End If
        End If
    Else
        If rtb.Text.Compare(rtb.Text, compareStr) <> 0 Then
            Dim result As New MsgBoxResult
            result = MsgBox(filename & " 文件的文字已经改变。" & Chr(10) & Chr(10) & "想保存文件吗？", MsgBoxStyle.YesNoCancel + MsgBoxStyle.Exclamation, "记事本")

            If result = MsgBoxResult.Yes Then
                Dim fstream As FileStream
                Dim sw As StreamWriter

                Try
                    'frmNew.Text = filename.Substring(filename.LastIndexOf("\") + 1) & "- 记事本"
                    fstream = New FileStream(filename, FileMode.Create, FileAccess.ReadWrite)
                    sw = New StreamWriter(fstream, System.Text.Encoding.Default)
                    sw.BaseStream.Seek(0, SeekOrigin.End)
                    sw.Write(rtb.Text)
                    sw.Flush()
                Catch ex As Exception
                    MsgBox("保存文件失败")
                Finally
                    sw.Close()
                End Try
            ElseIf result = MsgBoxResult.No Then
                rtb.Text = ""
            End If
        End If
    End If
End Sub
```

## 全局热键

```VB
Public Class Form1
  Public Const WM_HOTKEY = &H312
  Public Const MOD_ALT = &H1
  Public Const MOD_CONTROL = &H2
  Public Const MOD_SHIFT = &H4
  Public Const GWL_WNDPROC = (-4)
  Public Declare Auto Function RegisterHotKey Lib "user32.dll" Alias _
    "RegisterHotKey" (ByVal hwnd As IntPtr, ByVal id As Integer, ByVal fsModifiers As  Integer, ByVal vk As Integer) As Boolean
        
  Public Declare Auto Function UnRegisterHotKey Lib "user32.dll" Alias _
    "UnregisterHotKey" (ByVal hwnd As IntPtr, ByVal id As Integer) As Boolean

  Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
    '注册全局热键
    RegisterHotKey(Handle, 0, MOD_CONTROL, Asc("T")) '第一个热键 Ctrl+T
    RegisterHotKey(Handle, 1, Nothing, Keys.F4) '第二个热键 F4
  End Sub

  Private Sub  Form1_FormClosed(ByVal sender As System.Object, ByVal e As  System.Windows.Forms.FormClosedEventArgs) Handles MyBase.FormClosed
    '注销全局热键
    UnRegisterHotKey(Handle, 0)
    UnRegisterHotKey(Handle, 1)
  End Sub
 
  Protected Overrides Sub WndProc(ByRef m As Message)
    If m.Msg = WM_HOTKEY Then
      MsgBox("在这里添加你要执行的代码", MsgBoxStyle.Information, "全局热键")
    End If
    MyBase.WndProc(m)
  End Sub
End Class
```

## 局部快捷键

```VB
Private Sub Frm_KeyDown(sender As Object, e As KeyEventArgs) Handles Me.KeyDown
        If e.KeyData = (Keys.Control Or Keys.F) Then
            'csControl_Search.Tool_Btn_Find(Me, csXarrayDB, Me.Name, m_strEditStaffCode)
End If
End Sub
```

## 屏蔽系统热键

使用VB.net编写屏蔽热键的方法有很多中,比如说使用系统的API函数,也可以使用钩子来进行屏蔽.还有一种就是.net带的一种方法,首先来判断所按下去的键,然后再执行操作等事件.比如说:

```VB
if (e.keycode==keys.D){e.handle=true}
```

在keydown事件里面处理!这样就可以屏蔽了D键. 实例:

```VB
if  ((Control.ModifierKeys == Keys.Alt)  (e.KeyCode == Keys.F4)){e.Handled = true;}
```

还有一种办法就是不通过屏蔽热键来实现,就是通过设置焦点.你可以把你程序窗口设置为主焦点,这样其他程序一般就无法在你的程序前面了.实现屏蔽的作用.至于任务管理器的话可以通过杀掉进程的办法做到.如下:   

```C#
Process[] p = Process.GetProcesses();
foreach (Process p1  in p){
try{if (p1.ProcessName.ToLower().Trim() == "taskmgr")'这里判断是任务管理器   
{
 p1.Kill();
 return;
 }
 }
 catch{
return;
}
}}
```

以上是使用C#编写的,稍微改下就可以了,在,NET里面都差不多!

























